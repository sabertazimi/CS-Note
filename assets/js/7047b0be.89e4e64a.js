"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[2464],{8027:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"Language/Rust/RustBasicNotes","title":"Rust Basic Notes","description":"Toolchain","source":"@site/notes/Language/Rust/RustBasicNotes.md","sourceDirName":"Language/Rust","slug":"/Language/Rust/RustBasicNotes","permalink":"/awesome-notes/Language/Rust/RustBasicNotes","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/awesome-notes/edit/main/notes/Language/Rust/RustBasicNotes.md","tags":[{"inline":true,"label":"Language","permalink":"/awesome-notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/awesome-notes/tags/rust"}],"version":"current","lastUpdatedBy":"sabertazimi","lastUpdatedAt":1712724461000,"frontMatter":{"author":"Sabertazimi","authorTitle":"Web Developer","authorURL":"https://github.com/sabertazimi","authorImageURL":"https://github.com/sabertazimi.png","tags":["Language","Rust"]},"sidebar":"tutorialSidebar","previous":{"title":"Python Basic Notes","permalink":"/awesome-notes/Language/Python/PythonBasicNotes"},"next":{"title":"Verilog Basic Notes","permalink":"/awesome-notes/Language/Verilog/VerilogBasicNotes"}}');var t=r(5105),l=r(842);const i={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Language","Rust"]},a="Rust Basic Notes",c={},o=[{value:"Toolchain",id:"toolchain",level:2},{value:"Installation",id:"installation",level:3},{value:"Cargo",id:"cargo",level:3},{value:"Cargo Basic Commands",id:"cargo-basic-commands",level:4},{value:"Cargo Cache",id:"cargo-cache",level:4},{value:"Cargo Configuration",id:"cargo-configuration",level:4},{value:"GitHub Action",id:"github-action",level:3},{value:"Memory Model",id:"memory-model",level:2},{value:"Stack Value",id:"stack-value",level:3},{value:"Heap Value",id:"heap-value",level:3},{value:"Ownership",id:"ownership",level:2},{value:"Copy Trait",id:"copy-trait",level:3},{value:"Reference Type",id:"reference-type",level:3},{value:"String Type",id:"string-type",level:2},{value:"Struct Type",id:"struct-type",level:2},{value:"Tuple Struct",id:"tuple-struct",level:3},{value:"Unit-like Struct",id:"unit-like-struct",level:3},{value:"Enum Type",id:"enum-type",level:2},{value:"Array Type",id:"array-type",level:2},{value:"Type Alias",id:"type-alias",level:2},{value:"Type Conversion",id:"type-conversion",level:2},{value:"From Trait",id:"from-trait",level:3},{value:"Explicit Type Conversion",id:"explicit-type-conversion",level:3},{value:"Implicit Type Conversion",id:"implicit-type-conversion",level:3},{value:"Dynamically Sized Type",id:"dynamically-sized-type",level:2},{value:"Sized Trait",id:"sized-trait",level:3},{value:"Flow Control",id:"flow-control",level:2},{value:"If Statement",id:"if-statement",level:3},{value:"Loop Statement",id:"loop-statement",level:3},{value:"For Loop Statement",id:"for-loop-statement",level:4},{value:"While Loop Statement",id:"while-loop-statement",level:4},{value:"Loop Expression",id:"loop-expression",level:4},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Enum Pattern Matching",id:"enum-pattern-matching",level:3},{value:"Tuple Pattern Matching",id:"tuple-pattern-matching",level:3},{value:"Struct Pattern Matching",id:"struct-pattern-matching",level:3},{value:"Match Guard",id:"match-guard",level:3},{value:"Match Assignment",id:"match-assignment",level:3},{value:"Method",id:"method",level:2},{value:"Self",id:"self",level:3},{value:"Generics",id:"generics",level:2},{value:"Traits",id:"traits",level:2},{value:"Orphan Rule",id:"orphan-rule",level:3},{value:"Trait Bound",id:"trait-bound",level:3},{value:"Trait Derive",id:"trait-derive",level:3},{value:"Trait Object",id:"trait-object",level:3},{value:"Associated Types",id:"associated-types",level:3},{value:"Common Traits",id:"common-traits",level:3},{value:"Collection",id:"collection",level:2},{value:"Vector",id:"vector",level:3},{value:"HashMap",id:"hashmap",level:3},{value:"HashSet",id:"hashset",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Result Type",id:"result-type",level:3},{value:"Result Type Compositor",id:"result-type-compositor",level:3},{value:"Error Handling Macro",id:"error-handling-macro",level:3},{value:"Error Trait",id:"error-trait",level:3},{value:"Standard Error Trait",id:"standard-error-trait",level:4},{value:"Custom Error Type",id:"custom-error-type",level:4},{value:"Convert From Standard Error",id:"convert-from-standard-error",level:4},{value:"Format Print",id:"format-print",level:2},{value:"Format Print Macros",id:"format-print-macros",level:3},{value:"Format Print Placeholder",id:"format-print-placeholder",level:3},{value:"Debug Trait",id:"debug-trait",level:3},{value:"Display Trait",id:"display-trait",level:3},{value:"Lifetime",id:"lifetime",level:2},{value:"Function Lifetime",id:"function-lifetime",level:3},{value:"Static Lifetime",id:"static-lifetime",level:3},{value:"Lifetime Constraint",id:"lifetime-constraint",level:3},{value:"Closure",id:"closure",level:2},{value:"Function Parameter Closure",id:"function-parameter-closure",level:3},{value:"Function Return Closure",id:"function-return-closure",level:3},{value:"Iterator",id:"iterator",level:2},{value:"Iterator Trait",id:"iterator-trait",level:3},{value:"Adapter Methods",id:"adapter-methods",level:3},{value:"Smart Pointer",id:"smart-pointer",level:2},{value:"Box Type",id:"box-type",level:3},{value:"Deref Trait",id:"deref-trait",level:3},{value:"Drop Trait",id:"drop-trait",level:3},{value:"Reference Counting Type",id:"reference-counting-type",level:3},{value:"Cell and RefCell Type",id:"cell-and-refcell-type",level:3},{value:"Circle Reference",id:"circle-reference",level:3},{value:"Phantom Type",id:"phantom-type",level:2},{value:"Concurrent Programming",id:"concurrent-programming",level:2},{value:"Concurrency Programming Model",id:"concurrency-programming-model",level:3},{value:"Threads",id:"threads",level:3},{value:"Barrier",id:"barrier",level:3},{value:"Condition Variables and Mutex",id:"condition-variables-and-mutex",level:3},{value:"Threads Communication",id:"threads-communication",level:3},{value:"Tokio Semaphore",id:"tokio-semaphore",level:3},{value:"Atomic Primitives",id:"atomic-primitives",level:3},{value:"Send and Sync Trait",id:"send-and-sync-trait",level:3},{value:"Thread Pool",id:"thread-pool",level:3},{value:"Asynchronous Programming",id:"asynchronous-programming",level:2},{value:"Async and Await",id:"async-and-await",level:3},{value:"Future Trait",id:"future-trait",level:3},{value:"Asynchronous Runtime",id:"asynchronous-runtime",level:3},{value:"IO",id:"io",level:2},{value:"Path",id:"path",level:3},{value:"Files",id:"files",level:3},{value:"System",id:"system",level:2},{value:"Process",id:"process",level:3},{value:"Command Line",id:"command-line",level:3},{value:"Tests",id:"tests",level:2},{value:"Macros",id:"macros",level:2},{value:"Unsafe Code",id:"unsafe-code",level:2},{value:"Comments",id:"comments",level:2},{value:"Attributes",id:"attributes",level:2},{value:"Crate Attributes",id:"crate-attributes",level:3},{value:"Linter Attributes",id:"linter-attributes",level:3},{value:"Compile Attributes",id:"compile-attributes",level:3},{value:"Standard Library",id:"standard-library",level:2},{value:"Web Development",id:"web-development",level:2},{value:"Node.js Bindings",id:"nodejs-bindings",level:3},{value:"Library",id:"library",level:2},{value:"Reference",id:"reference",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"rust-basic-notes",children:"Rust Basic Notes"})}),"\n",(0,t.jsx)(e.h2,{id:"toolchain",children:"Toolchain"}),"\n",(0,t.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# RustUp script.\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n# Setup environment variables.\necho '. $HOME/.cargo/env' >> ~/.zshrc\n# Install GCC linker and OpenSSL.\nsudo apt install build-essential libssl-dev pkg-config\n# Done.\ncargo -V\nrustc -V\n"})}),"\n",(0,t.jsx)(e.h3,{id:"cargo",children:"Cargo"}),"\n",(0,t.jsx)(e.h4,{id:"cargo-basic-commands",children:"Cargo Basic Commands"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"cargo new hello_world\ncargo run\ncargo build\ncargo run --release\ncargo build --release\ncargo check\ncargo generate-lockfile\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"cargo fmt --check\ncargo clippy\ncargo test\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"cargo install cargo-edit\ncargo install cargo-release\ncargo install cargo-tarpaulin\ncargo install cargo-watch\ncargo install cargo-workspaces\n"})}),"\n",(0,t.jsx)(e.p,{children:"Cargo release configuration:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-toml",children:'[workspace.metadata.release]\n# cargo install cargo-release\n# cargo release -x\nsign-commit = true\nsign-tag = true\nrelease = false\npush = false\npublish = false\nshared-version = true\npre-release-commit-message = "chore(release): {{version}}"\npost-release-commit-message = "chore(release): {{version}}"\ntag-message = "{{tag_name}}"\n'})}),"\n",(0,t.jsx)(e.h4,{id:"cargo-cache",children:"Cargo Cache"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"~/.cargo/"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"config.toml"}),": global configuration."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"credentials.toml"}),": ",(0,t.jsx)(e.code,{children:"cargo login"})," related file."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:".crates.toml"}),"/",(0,t.jsx)(e.code,{children:".crates2.json"}),": installed package information."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"bin/"}),": installed binaries."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"git/"}),": installed rust git repositories.","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"git/db/"}),": installed git repositories."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"git/checkouts/"}),": branches of git repositories."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"registry/"}),": ",(0,t.jsx)(e.code,{children:"crates.io"})," metadata and packages.","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"registry/index/"}),": metadata git repository."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"registry/cache/"}),": dependencies cache (",(0,t.jsx)(e.code,{children:".crate"})," gzip files)."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"registry/src/"}),": package source files."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"cargo-configuration",children:"Cargo Configuration"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Cargo.toml"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"cargo-features"}),": \u53ea\u80fd\u7528\u4e8e ",(0,t.jsx)(e.code,{children:"nightly"}),"\u7248\u672c\u7684 ",(0,t.jsx)(e.code,{children:"feature"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[package]"}),": \u5b9a\u4e49\u9879\u76ee( ",(0,t.jsx)(e.code,{children:"package"})," )\u7684\u5143\u4fe1\u606f.","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"name"}),": \u540d\u79f0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"version"}),": \u7248\u672c."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"authors"}),": \u5f00\u53d1\u4f5c\u8005."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"edition"}),": Rust edition.."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"rust-version"}),": \u652f\u6301\u7684\u6700\u5c0f\u5316 Rust \u7248\u672c."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"description"}),": \u63cf\u8ff0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"documentation"}),": \u6587\u6863 URL."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"readme"}),": README \u6587\u4ef6\u7684\u8def\u5f84."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"homepage"}),": \u4e3b\u9875 URL."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"repository"}),": \u6e90\u4ee3\u7801\u4ed3\u5e93\u7684 URL."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"license"}),": \u5f00\u6e90\u534f\u8bae License.."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"license-file"}),": License \u6587\u4ef6\u7684\u8def\u5f84.."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"keywords"}),": \u9879\u76ee\u7684\u5173\u952e\u8bcd."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"categories"}),": \u9879\u76ee\u5206\u7c7b."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"workspace"}),": \u5de5\u4f5c\u7a7a\u95f4 workspace \u7684\u8def\u5f84."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"build"}),": \u6784\u5efa\u811a\u672c\u7684\u8def\u5f84."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"links"}),": \u672c\u5730\u94fe\u63a5\u5e93\u7684\u540d\u79f0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"exclude"}),": \u53d1\u5e03\u65f6\u6392\u9664\u7684\u6587\u4ef6."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"include"}),": \u53d1\u5e03\u65f6\u5305\u542b\u7684\u6587\u4ef6."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"publish"}),": \u7528\u4e8e\u963b\u6b62\u9879\u76ee\u7684\u53d1\u5e03."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"metadata"}),": \u989d\u5916\u7684\u914d\u7f6e\u4fe1\u606f\uff0c\u7528\u4e8e\u63d0\u4f9b\u7ed9\u5916\u90e8\u5de5\u5177."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"default-run"}),": [",(0,t.jsx)(e.code,{children:"cargo run"}),"] \u6240\u4f7f\u7528\u7684\u9ed8\u8ba4\u53ef\u6267\u884c\u6587\u4ef6( binary )."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"autobins"}),": \u7981\u6b62\u53ef\u6267\u884c\u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"autoexamples"}),": \u7981\u6b62\u793a\u4f8b\u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"autotests"}),": \u7981\u6b62\u6d4b\u8bd5\u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"autobenches"}),": \u7981\u6b62 bench \u6587\u4ef6\u7684\u81ea\u52a8\u53d1\u73b0."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"resolver"}),": \u8bbe\u7f6e\u4f9d\u8d56\u89e3\u6790\u5668( dependency resolver)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Cargo target configuration:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[lib]"}),": Library target."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[[bin]]"}),": Binary target."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[[example]]"}),": Example target."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[[test]]"}),": Test target."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[[bench]]"}),": Benchmark target."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Dependency tables:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[dependencies]"}),": \u9879\u76ee\u4f9d\u8d56\u5305."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[dev-dependencies]"}),":\n\u7528\u4e8e examples\u3001tests \u548c benchmarks \u7684\u4f9d\u8d56\u5305."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[build-dependencies]"}),": \u7528\u4e8e\u6784\u5efa\u811a\u672c\u7684\u4f9d\u8d56\u5305."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[target]"}),": \u5e73\u53f0\u7279\u5b9a\u7684\u4f9d\u8d56\u5305."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[badges]"}),": \u7ef4\u62a4\u72b6\u6001."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[features]"}),": ",(0,t.jsx)(e.code,{children:"features"})," \u53ef\u4ee5\u7528\u4e8e\u6761\u4ef6\u7f16\u8bd1."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[patch]"}),": \u63a8\u8350\u4f7f\u7528\u7684\u4f9d\u8d56\u8986\u76d6\u65b9\u5f0f."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[profile]"}),": \u7f16\u8bd1\u5668\u8bbe\u7f6e\u548c\u4f18\u5316."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"[workspace]"}),": \u5de5\u4f5c\u7a7a\u95f4\u7684\u5b9a\u4e49."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"github-action",children:"GitHub Action"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Use ",(0,t.jsx)(e.a,{href:"https://github.com/mozilla/sccache",children:"tool"})," to speed up compilation."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yml",children:"name: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  test:\n    name: Test Suite\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - uses: actions-rs/cargo@v1\n        with:\n          command: test\n          args: --all-features --workspace\n\n  rustfmt:\n    name: Rustfmt\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n          components: rustfmt\n      - name: Check formatting\n        uses: actions-rs/cargo@v1\n        with:\n          command: fmt\n          args: --all -- --check\n\n  clippy:\n    name: Clippy\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n          components: clippy\n      - name: Clippy check\n        uses: actions-rs/cargo@v1\n        with:\n          command: clippy\n          args: --all-targets --all-features --workspace -- -D warnings\n\n  docs:\n    name: Docs\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Check documentation\n        env:\n          RUSTDOCFLAGS: -D warnings\n        uses: actions-rs/cargo@v1\n        with:\n          command: doc\n          args: --no-deps --document-private-items --all-features --workspace\n\n  publish-dry-run:\n    name: Publish dry run\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - uses: actions-rs/cargo@v1\n        with:\n          command: publish\n          args: --dry-run\n\n  coverage:\n    name: Code coverage\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n      - name: Run cargo-tarpaulin\n        uses: actions-rs/tarpaulin@v0.1\n        with:\n          args: --all-features --workspace --ignore-tests --out Lcov\n      - name: Upload to Coveralls\n        if: ${{ github.event_name == 'push' }}\n        uses: coverallsapp/github-action@v1\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          path-to-lcov: ./lcov.info\n"})}),"\n",(0,t.jsx)(e.h2,{id:"memory-model",children:"Memory Model"}),"\n",(0,t.jsx)(e.h3,{id:"stack-value",children:"Stack Value"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Primitives"}),"\n",(0,t.jsx)(e.li,{children:"Fixed size struts."}),"\n",(0,t.jsx)(e.li,{children:"Fixed size arrays."}),"\n",(0,t.jsx)(e.li,{children:"Pointers and references."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"heap-value",children:"Heap Value"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Collections:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Arrays."}),"\n",(0,t.jsx)(e.li,{children:"Lists."}),"\n",(0,t.jsx)(e.li,{children:"Strings."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Dynamic sized objects:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Box."}),"\n",(0,t.jsx)(e.li,{children:"Trait objects."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"ownership",children:"Ownership"}),"\n",(0,t.jsx)(e.h3,{id:"copy-trait",children:"Copy Trait"}),"\n",(0,t.jsxs)(e.p,{children:["Copyable type (implement ",(0,t.jsx)(e.code,{children:"Copy"})," trait):"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Integer type."}),"\n",(0,t.jsx)(e.li,{children:"Bool type."}),"\n",(0,t.jsx)(e.li,{children:"Float type."}),"\n",(0,t.jsx)(e.li,{children:"Char type."}),"\n",(0,t.jsxs)(e.li,{children:["Copyable Tuple type, e.g ",(0,t.jsx)(e.code,{children:"(i32, i32)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Reference type (",(0,t.jsx)(e.strong,{children:"borrowing"})," ownership)."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Most these types store on stack\n(including reference type with vtable)."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // Primitive type.\n    let a = 5;\n    let b = a;\n\n    // Reference type.\n    let x: &str = "hello, world";\n    let y = x;\n\n    // Deep clone on `non-Copy` type.\n    let s1 = String::from("hello");\n    let s2 = s1.clone();\n\n    // Correct.\n    println!("a = {}, b = {}", a, b);\n    println!("x = {}, y = {}", x, y);\n    println!("s1 = {}, s2 = {}", s1, s2);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let s2 = s1;\n\n    // Error[E0382]: use of moved value: `s1`.\n    // Move occurs because `s1` has type `std::string::String`,\n    // which does not implement the `Copy` trait.\n    println!("{}, world!", s1);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"reference-type",children:"Reference Type"}),"\n",(0,t.jsx)(e.p,{children:"Borrowing ownership with reference type:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"At same time, only one mutable reference or multiple immutable reference."}),"\n",(0,t.jsx)(e.li,{children:"Reference should be valid (rustc will report dangling reference error)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n    // Leave function without drop `s`,\n    // due to `s` not owner string.\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Mutable reference:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Only one mutable reference for a value in a scope)."}),"\n",(0,t.jsx)(e.li,{children:"Can't mutable borrow an already immutable borrowed value."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n   let mut s = String::from("hello");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &mut s;\n\n    // Error.\n    println!("{}, {} and {}", r1, r2, r3);\n    // End of r1 and r2 borrowing.\n\n    // Correct.\n    let r4 = &mut s;\n    println!("{}", r4);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"string-type",children:"String Type"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"&str"})," string slice reference type:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Borrowing type."}),"\n",(0,t.jsx)(e.li,{children:"UTF-8 encode (1 ~ 4 bytes)."}),"\n",(0,t.jsxs)(e.li,{children:["String literal is ",(0,t.jsx)(e.code,{children:"&str"})," type."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let s = String::from("hello world");\nlet len = s.len();\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\nlet slice1 = &s[0..2];\nlet slice2 = &s[..2];\nlet slice3 = &s[4..len];\nlet slice4 = &s[4..];\nlet slice5 = &s[0..len];\nlet slice6 = &s[..];\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"String"})," type:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Ownership type."}),"\n",(0,t.jsx)(e.li,{children:"UTF-8 encode (1 ~ 4 bytes)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::new();\n    s.push_str("hello,world");\n    s.push(\'!\');\n    assert_eq!(s,"hello,world!");\n\n    let mut s = "hello,world".to_string();\n    s.push(\'!\');\n    assert_eq!(s,"hello,world!");\n\n    let mut s = String::from("\u4f60\u597d, \u4e16\u754c");\n    s.push(\'!\');\n    assert_eq!(s,"\u4f60\u597d, \u4e16\u754c!");\n\n    let s1 = String::from("hello,");\n    let s2 = String::from("world!");\n    let s3 = s1 + &s2;\n    assert_eq!(s3,"hello,world!");\n\n    for c in "\u4e2d\u56fd\u4eba".chars() {\n        println!("{}", c);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"struct-type",children:"Struct Type"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n\nlet user1 = User {\n    email: String::from("someone@example.com"),\n    username: String::from("username123"),\n    active: true,\n    sign_in_count: 1,\n};\n\nlet user2 = User {\n    email: String::from("another@example.com"),\n    ..user1\n};\n'})}),"\n",(0,t.jsx)(e.h3,{id:"tuple-struct",children:"Tuple Struct"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"newtype"}),": Wrap type into tuple struct:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Make code more readable."}),"\n",(0,t.jsx)(e.li,{children:"Implement 3rd traits for 3rd types."}),"\n",(0,t.jsx)(e.li,{children:"Hide internal details of types."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Meters(u32);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"unit-like-struct",children:"Unit-like Struct"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct AlwaysEqual;\nlet subject = AlwaysEqual;\nimpl SomeTrait for AlwaysEqual {}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"enum-type",children:"Enum Type"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let m1 = Message::Quit;\n    let m2 = Message::Move{x: 1, y: 1};\n    let m3 = Message::ChangeColor(255, 255, 0);\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum Option<T> {\n    Some(T),\n    None,\n}\n\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n"})}),"\n",(0,t.jsx)(e.h2,{id:"array-type",children:"Array Type"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let a: [i32; 5] = [1, 2, 3, 4, 5];\nlet b = [3; 5];\nlet slice: &[i32] = &a[1..3];\nassert_eq!(slice, &[2, 3]);\n\nfn main() {\n  let one             = [1, 2, 3];\n  let two: [u8; 3]    = [1, 2, 3];\n  let blank1          = [0; 3];\n  let blank2: [u8; 3] = [0; 3];\n\n  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];\n\n  for a in &arrays {\n    print!("{:?}: ", a);\n\n    for n in a.iter() {\n      print!("\\t{} + 10 = {}", n, n+10);\n    }\n\n    let mut sum = 0;\n\n    for i in 0..a.len() {\n      sum += a[i];\n    }\n\n    println!("\\t({:?} = {})", a, sum);\n  }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"type-alias",children:"Type Alias"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'type Meters = i32;\n\nlet x: u32 = 5;\nlet y: Meters = 5;\n\nprintln!("x + y = {}", x + y);\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'type Result<T> = std::result::Result<T, std::io::Error>;\ntype Thunk = Box<dyn Fn() + Send + \'static>;\n\nlet f: Thunk = Box::new(|| println!("hi"));\nfn takes_long_type(f: Thunk) {}\nfn returns_long_type() -> Thunk {}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"type-conversion",children:"Type Conversion"}),"\n",(0,t.jsx)(e.h3,{id:"from-trait",children:"From Trait"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!("My number is {:?}", num);\n\n    let int = 5;\n    let num: Number = int.into();\n    println!("My number is {:?}", num);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom<i32> for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n    let result: Result<EvenNumber, ()> = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result<EvenNumber, ()> = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"explicit-type-conversion",children:"Explicit Type Conversion"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let a = 3.1 as i8;\n    let b = 100_i8 as i32;\n    let c = \'a\' as u8;\n    println!("{}, {}, {}", a, b, c)\n\n    let x: i16 = 1500;\n    let x_: u8 = match x.try_into() {\n        Ok(x1) => x1,\n        Err(e) => {\n            println!("{:?}", e.to_string());\n            0\n        }\n    };\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"implicit-type-conversion",children:"Implicit Type Conversion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"target.method()"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["Call by value: ",(0,t.jsx)(e.code,{children:"T::method(target)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Call by reference: ",(0,t.jsx)(e.code,{children:"T::method(&target)"})," or ",(0,t.jsx)(e.code,{children:"T::method(&mut target)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Call by deref: when ",(0,t.jsx)(e.code,{children:"T: Deref<Target = U>"}),", then ",(0,t.jsx)(e.code,{children:"(&T).method() => (&U).method()"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"Length-non-determined collection to length-determined slice."}),"\n",(0,t.jsx)(e.li,{children:"Panic."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"let array: Rc<Box<[T; 3]>> = ...;\nlet first_entry = array[0];\n// 1. `Index` trait grammar sugar: array[0] => array.index(0).\n// 2. Call by: value: `Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 3. Call by reference: `&Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 4. Call by reference: `&mut Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 5. Call by deref -> Call by value: `Box<[T; 3]>` not impl `Index` trait.\n// 6. Call by deref -> Call by reference: `&Box<[T; 3]>` not impl `Index` trait.\n// 7. Call by deref -> Call by reference: `&mut Box<[T; 3]>` not impl `Index` trait.\n// 8. Call by deref -> Call by deref: `[T; 3]` not impl `Index` trait.\n// 9. `[T; 3]` => `[T]` impl `Index` trait.\n"})}),"\n",(0,t.jsx)(e.h2,{id:"dynamically-sized-type",children:"Dynamically Sized Type"}),"\n",(0,t.jsx)(e.p,{children:"DST:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["DST \u65e0\u6cd5\u5355\u72ec\u88ab\u4f7f\u7528, \u5fc5\u987b\u8981\u901a\u8fc7 ",(0,t.jsx)(e.code,{children:"&"}),"/",(0,t.jsx)(e.code,{children:"Box"}),"/",(0,t.jsx)(e.code,{children:"Rc"})," \u6765\u95f4\u63a5\u4f7f\u7528."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"str"}),", ",(0,t.jsx)(e.code,{children:"[T]"}),", ",(0,t.jsx)(e.code,{children:"dyn Trait"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Error!\nlet s1: str = "Hello there!";\nlet s2: str = "How\'s it going?";\n\n// Ok.\nlet s3: &str = "on?"\nlet s4: Box<str> = "Hello there!".into();\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// Error!\nfn my_function(n: usize) {\n    let array = [123; n];\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn foobar_1(thing: &dyn MyThing) {}     // OK.\nfn foobar_2(thing: Box<dyn MyThing>) {} // OK.\nfn foobar_3(thing: Rc<dyn MyThing>) {}  // OK.\nfn foobar_4(thing: MyThing) {}          // ERROR!\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sized-trait",children:"Sized Trait"}),"\n",(0,t.jsx)(e.p,{children:"Implicit sized trait:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn generic<T>(t: T) {}\n// Auto-transform to by Rust compiler\nfn generic<T: Sized>(t: T) {}\n"})}),"\n",(0,t.jsx)(e.p,{children:"Dynamic sized generics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn generic<T: ?Sized>(t: &T) {}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"flow-control",children:"Flow Control"}),"\n",(0,t.jsx)(e.h3,{id:"if-statement",children:"If Statement"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"if"})," expression:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"let number = if condition {\n    5\n} else {\n    6\n};\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"if let"})," expression:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"let o = Some(3);\nlet v = if let Some(x) = o {\n    x\n} else {\n    0\n};\n"})}),"\n",(0,t.jsx)(e.h3,{id:"loop-statement",children:"Loop Statement"}),"\n",(0,t.jsx)(e.h4,{id:"for-loop-statement",children:"For Loop Statement"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"for i in 1..=5 {}\nfor _ in 0..10 {}\nfor item in collection {}\nfor item in &collection {}\nfor item in &mut collection {}\nfor (i, v) in collection.iter().enumerate() {}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"while-loop-statement",children:"While Loop Statement"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut n = 0;\n\n    while n <= 5  {\n        println!("{}!", n);\n        n = n + 1;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"loop-expression",children:"Loop Expression"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!("The result is {}", result);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"match target {\n    pattern1 => expression1,\n    pattern2 => {\n        statement1;\n        statement2;\n        expression2\n    },\n    _ => expression3\n}\n\nif let pattern = target {\n    statement;\n    expression\n}\n\nwhile let pattern = target {\n    statement;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"enum-pattern-matching",children:"Enum Pattern Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'enum Action {\n    Say(String),\n    MoveTo(i32, i32),\n    ChangeColorRGB(u16, u16, u16),\n}\n\nfn main() {\n    let actions = [\n        Action::Say("Hello Rust".to_string()),\n        Action::MoveTo(1,2),\n        Action::ChangeColorRGB(255,255,0),\n    ];\n\n    for action in actions {\n        match action {\n            Action::Say(s) => {\n                println!("{}", s);\n            },\n            Action::MoveTo(x, y) => {\n                println!("point from (0, 0) move to ({}, {})", x, y);\n            },\n            Action::ChangeColorRGB(r, g, _) => {\n                println!("change color into \'(r:{}, g:{}, b:0)\', \'b\' has been ignored",\n                    r, g,\n                );\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"tuple-pattern-matching",children:"Tuple Pattern Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!("Some numbers: {}, {}", first, last);\n        },\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"struct-pattern-matching",children:"Struct Pattern Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'struct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7, z: 0 };\n    let Point { x: a, y: b, z: c } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n    assert_eq!(0, c);\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n    match origin {\n        Point { x, .. } => println!("x is {}", x),\n    }\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!("On the x axis at {}", x),\n        Point { x: 0, y } => println!("On the y axis at {}", y),\n        Point { x, y } => println!("On neither axis: ({}, {})", x, y),\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"match-guard",children:"Match Guard"}),"\n",(0,t.jsxs)(e.p,{children:["Combine pattern matching and ",(0,t.jsx)(e.code,{children:"if"})," expression:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let num = Some(4);\n\nmatch num {\n    Some(x) if x < 5 => println!("less than five: {}", x),\n    Some(x) => println!("{}", x),\n    None => (),\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"match-assignment",children:"Match Assignment"}),"\n",(0,t.jsxs)(e.p,{children:["Combine pattern matching and ",(0,t.jsx)(e.code,{children:"@"})," expression:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'enum Message {\n    Hello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!("Found an id in range: {}", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!("Found an id in another range")\n    },\n    Message::Hello { id } => {\n        println!("Found some other id: {}", id)\n    },\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};\n    println!("x: {}, y: {}", px, py);\n    println!("{:?}", p);\n\n    let point = Point {x: 10, y: 5};\n    if let p @ Point {x: 10, y} = point {\n        println!("x is 10 and y is {} in {:?}", y, p);\n    } else {\n        println!("x was not 10 :(");\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"method",children:"Method"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn new(x: f64, y: f64, radius: f64) -> Circle {\n        Circle {\n            x,\n            y,\n            radius,\n        }\n    }\n\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nimpl Message {\n    fn call(&self) {}\n}\n\nfn main() {\n    let m = Message::Write(String::from("hello"));\n    m.call();\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"self",children:"Self"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"self"}),": \u6240\u6709\u6743\u8f6c\u79fb."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&self"}),": \u4e0d\u53ef\u53d8\u501f\u7528."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&mut self"}),": \u53ef\u53d8\u501f\u7528."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'pub struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    pub fn new(width: u32, height: u32) -> Self {\n        Rectangle { width, height }\n    }\n    pub fn width(&self) -> u32 {\n        return self.width;\n    }\n    pub fn height(&self) -> u32 {\n        return self.height;\n    }\n}\n\nfn main() {\n    let rect = Rectangle::new(30, 50);\n    println!("{}", rect.width());\n    println!("{}", rect.height());\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"generics",children:"Generics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n\n    fn mixup<U>(self, other: Point<U>) {}\n}\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nfn add<T: std::ops::Add<T, Output = T>>(a:T, b:T) -> T {\n    a + b\n}\n\nfn largest<T: PartialOrd>(list: &[T]) -> T {}\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["TurboFish:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"generics_struct::<T>::method()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"struct.generics_method::<T>()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.li,{children:"Use associated types in traits."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"traits",children:"Traits"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'pub struct Post {\n    pub username: String,\n    pub content: String\n}\n\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!("(Read more from {}...)", self.summarize_author())\n    }\n}\n\nimpl Summary for Post {\n    fn summarize_author(&self) -> String {\n        format!("@{}", self.username)\n    }\n}\n\nfn main() {\n    let post = Post{username: "username".to_string(),content: "content".to_string()};\n    println!("1 new post: {}", post.summarize());\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"orphan-rule",children:"Orphan Rule"}),"\n",(0,t.jsxs)(e.p,{children:["Rust can\u2019t implement external traits on external types:\ncan\u2019t implement the ",(0,t.jsx)(e.code,{children:"Display"})," trait on ",(0,t.jsx)(e.code,{children:"Vec<T>"})," in ",(0,t.jsx)(e.code,{children:"some_package"})," crate,\nbecause ",(0,t.jsx)(e.code,{children:"Display"})," and ",(0,t.jsx)(e.code,{children:"Vec<T>"})," are ",(0,t.jsx)(e.strong,{children:"both"})," defined out of ",(0,t.jsx)(e.code,{children:"some_package"}),".\nThis restriction is part of a property of programs called coherence,\nensures that other people\u2019s code can\u2019t break your code and vice versa."]}),"\n",(0,t.jsx)(e.h3,{id:"trait-bound",children:"Trait Bound"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn notify(item: &impl Summary) {}\nfn notify(item: &(impl Summary + Display)) {}\nfn notify<T: Summary>(item: &T) {}\nfn notify<T: Summary + Display>(item: &T) {}\nfn notify<T, U>(t: &T, u: &U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait SomeTrait: BoundTrait {}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// \u53ef\u4ee5\u5bf9\u4efb\u4f55\u5b9e\u73b0\u4e86 Display \u7279\u5f81\u7684\u7c7b\u578b\u8c03\u7528 ToString \u7279\u5f81\u4e2d\u65b9\u6cd5.\nimpl<T: Display> ToString for T {}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"trait-derive",children:"Trait Derive"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"#[derive(Debug)]\n#[derive(PartialEq)]\n#[derive(Eq)]\n#[derive(PartialOrd)]\n#[derive(Ord)]\n#[derive(Clone)]\n#[derive(Copy)]\n#[derive(Hash)]\n#[derive(Default)]\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'trait Person {\n    fn name(&self) -> String;\n}\n\ntrait Student: Person {\n    fn university(&self) -> String;\n}\n\ntrait Programmer {\n    fn fav_language(&self) -> String;\n}\n\ntrait CompSciStudent: Programmer + Student {\n    fn git_username(&self) -> String;\n}\n\nfn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {\n    format!(\n        "My name is {} and I attend {}. My language is {}. My Git username is {}",\n        student.name(),\n        student.university(),\n        student.fav_language(),\n        student.git_username()\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"trait-object",children:"Trait Object"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Define trait object:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Box<dyn some_trait>"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&dyn some_trait"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["A trait can have trait object only when\nit is ",(0,t.jsx)(e.code,{children:"object safe"}),":","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["all methods can't return ",(0,t.jsx)(e.code,{children:"Self"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"all methods can't be generics."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Trait object has ",(0,t.jsx)(e.code,{children:"'static"})," lifetime."]}),"\n",(0,t.jsx)(e.li,{children:"Trait object stand for dynamic distributing (runtime),\ngenerics stand for static distributing (compile time)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'trait Draw {\n    fn draw(&self) -> String;\n}\n\nimpl Draw for u8 {\n    fn draw(&self) -> String {\n        format!("u8: {}", *self)\n    }\n}\n\nimpl Draw for f64 {\n    fn draw(&self) -> String {\n        format!("f64: {}", *self)\n    }\n}\n\nfn draw1(x: Box<dyn Draw>) {\n    x.draw();\n}\n\nfn draw2(x: &dyn Draw) {\n    x.draw();\n}\n\nfn main() {\n    let x = 1.1f64;\n    let y = 8u8;\n\n    draw1(Box::new(x));\n    draw1(Box::new(y));\n    draw2(&x);\n    draw2(&y);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"associated-types",children:"Associated Types"}),"\n",(0,t.jsx)(e.p,{children:"Associated types make code become readable and concise:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait Container<A,B> {\n    fn contains(&self,a: A,b: B) -> bool;\n}\n\nfn difference<A,B,C>(container: &C) -> i32\n  where\n    C : Container<A,B> {}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait Container{\n    type A;\n    type B;\n    fn contains(&self, a: &Self::A, b: &Self::B) -> bool;\n}\n\nfn difference<C: Container>(container: &C) {}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["For all ",(0,t.jsx)(e.strong,{children:"generic trait"}),",\nuse associated types better than ",(0,t.jsx)(e.code,{children:"<T>"}),"."]}),"\n",(0,t.jsx)(e.h3,{id:"common-traits",children:"Common Traits"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::fmt::Display"})," (better than ",(0,t.jsx)(e.code,{children:"std::string::ToString"}),")."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::fmt::Debug"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Add"}),"/",(0,t.jsx)(e.code,{children:"Mul"}),"/",(0,t.jsx)(e.code,{children:"Div"}),"/",(0,t.jsx)(e.code,{children:"BitAnd"}),"/",(0,t.jsx)(e.code,{children:"BitOr"}),"/",(0,t.jsx)(e.code,{children:"Not"}),"/",(0,t.jsx)(e.code,{children:"Neg"}),": operators overload."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Fn"}),"/",(0,t.jsx)(e.code,{children:"FnMut"}),"/",(0,t.jsx)(e.code,{children:"FnOnce"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Deref"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Drop"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::clone::Clone"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::iter::Iterator"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"std::prelude"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::marker::{Copy, Send, Sized, Sync, Unpin}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::{Drop, Fn, FnMut, FnOnce}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::mem::drop"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::boxed::Box"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::borrow::ToOwned"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::clone::Clone"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::cmp::{PartialEq, PartialOrd, Eq, Ord}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::convert::{AsRef, AsMut, Into, From}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::default::Default"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::option::Option::{self, Some, None}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::result::Result::{self, Ok, Err}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::string::{String, ToString}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::vec::Vec"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::convert::{TryFrom, TryInto}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::iter::FromIterator"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::io::prelude::*;\n"})}),"\n",(0,t.jsx)(e.h2,{id:"collection",children:"Collection"}),"\n",(0,t.jsx)(e.h3,{id:"vector",children:"Vector"}),"\n",(0,t.jsx)(e.p,{children:"Create and Insert:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"let mut v = Vec::new();\nv.push(1);\n"})}),"\n",(0,t.jsx)(e.p,{children:"Access and Get:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let v = vec![1, 2, 3, 4, 5];\n\nlet third: &i32 = &v[2];\nprintln!("3rd: {}", third);\n\nmatch v.get(2) {\n    Some(third) => println!("3rd: {}", third),\n    None => println!("None."),\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Visit:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let v = vec![1, 2, 3];\n\nfor i in &v {\n    println!("{}", i);\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Visit and Mutate:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"let mut v = vec![1, 2, 3];\n\nfor i in &mut v {\n    *i += 10\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"Store different types:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'enum IpAddr {\n    V4(String),\n    V6(String)\n}\n\nfn main() {\n    let v = vec![\n        IpAddr::V4("127.0.0.1".to_string()),\n        IpAddr::V6("::1".to_string())\n    ];\n\n    for ip in v {\n        show_addr(ip)\n    }\n}\n\nfn show_addr(ip: IpAddr) {\n    println!("{:?}",ip);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"hashmap",children:"HashMap"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::collections::HashMap;\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Create.\nlet mut scores = HashMap::new();\n\n// Insert.\nscores.insert(String::from("Blue"), 10);\nscores.insert(String::from("Yellow"), 50);\nscores.entry("Red").or_insert(5);\n\n// Get.\nlet team_name = String::from("Blue");\nlet score: Option<&i32> = scores.get(&team_name);\n\n// Visit\nfor (key, value) in &scores {\n    println!("{}: {}", key, value);\n}\n\n// Transform.\nlet from_list: HashMap<_,_> = some_list.into_iter().collect();\n'})}),"\n",(0,t.jsx)(e.h3,{id:"hashset",children:"HashSet"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"insert."}),"\n",(0,t.jsx)(e.li,{children:"contains."}),"\n",(0,t.jsx)(e.li,{children:"union."}),"\n",(0,t.jsx)(e.li,{children:"difference."}),"\n",(0,t.jsx)(e.li,{children:"intersection."}),"\n",(0,t.jsx)(e.li,{children:"symmetric_difference."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(e.h3,{id:"result-type",children:"Result Type"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open("hello.txt");\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create("hello.txt") {\n                Ok(fc) => fc,\n                Err(e) => panic!("Problem creating the file: {:?}", e),\n            },\n            other_error => panic!("Problem opening the file: {:?}", other_error),\n        },\n    };\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"result-type-compositor",children:"Result Type Compositor"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"or"}),": logic or."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"and"}),": logic and."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"or_else"}),": logic or function."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"and_then"}),": logic and function."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"filter"}),": ",(0,t.jsx)(e.code,{children:"Option"})," filter function."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"map"}),": ",(0,t.jsx)(e.code,{children:"Ok"}),"/",(0,t.jsx)(e.code,{children:"Some"})," map function."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"map_or"}),": ",(0,t.jsx)(e.code,{children:"Ok"}),"/",(0,t.jsx)(e.code,{children:"Some"})," map function with defaults value."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"map_or_else"}),": ",(0,t.jsx)(e.code,{children:"Ok"}),"/",(0,t.jsx)(e.code,{children:"Some"})," map function with defaults function."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"map_err"}),": ",(0,t.jsx)(e.code,{children:"Err"})," map function."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"ok_or"}),": ",(0,t.jsx)(e.code,{children:"Option"})," -> ",(0,t.jsx)(e.code,{children:"Result"})," with error message."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"ok_or_else"}),": ",(0,t.jsx)(e.code,{children:"Option"})," -> ",(0,t.jsx)(e.code,{children:"Result"})," with error message function."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"error-handling-macro",children:"Error Handling Macro"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"?"})," for ",(0,t.jsx)(e.code,{children:"Result"})," type:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs::File;\nuse std::io;\nuse std::io::Read;\n\nfn open_file() -> Result<File, Box<dyn std::error::Error>> {\n    let mut f = File::open("hello.txt")?;\n    Ok(f)\n}\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut s = String::new();\n    File::open("hello.txt")?.read_to_string(&mut s)?;\n    Ok(s)\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"?"})," for ",(0,t.jsx)(e.code,{children:"Option"})," type:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn last_char_of_first_line(text: &str) -> Option<char> {\n    text.lines().next()?.chars().last()\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"error-trait",children:"Error Trait"}),"\n",(0,t.jsx)(e.h4,{id:"standard-error-trait",children:"Standard Error Trait"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::fmt::{Debug, Display};\n\npub trait Error: Debug + Display {\n    fn source(&self) -> Option<&(Error + 'static)> { ... }\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs::read_to_string;\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let html = render()?;\n    println!("{}", html);\n    Ok(())\n}\n\nfn render() -> Result<String, Box<dyn Error>> {\n    let file = std::env::var("MARKDOWN")?;\n    let source = read_to_string(file)?;\n    Ok(source)\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"custom-error-type",children:"Custom Error Type"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::error;\nuse std::fmt;\n\n#[derive(Debug)]\nstruct AppError;\n\nimpl fmt::Display for AppError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, "An Error Occurred, Please Try Again!")\n    }\n}\n\nimpl error::Error for AppError {\n    fn description(&self) -> &str {\n        "Invalid App"\n    }\n\n    fn source(&self) -> Option<&(dyn error::Error + \'static)> {\n        None\n    }\n\n    fn cause(&self) -> Option<&dyn error::Error> {\n        None\n    }\n}\n\nfn produce_error() -> Result<(), AppError> {\n    Err(AppError)\n}\n\nfn main(){\n    match produce_error() {\n        Err(e) => eprintln!("{}", e),\n        _ => println!("No error"),\n    }\n\n    eprintln!("{:?}", produce_error()); // Err({ file: src/main.rs, line: 17 })\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"convert-from-standard-error",children:"Convert From Standard Error"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\n\n#[derive(Debug)]\nstruct AppError {\n    kind: String,\n    message: String,\n}\n\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError {\n            kind: String::from("io"),\n            message: error.to_string(),\n        }\n    }\n}\n\nimpl From<num::ParseIntError> for AppError {\n    fn from(error: num::ParseIntError) -> Self {\n        AppError {\n            kind: String::from("parse"),\n            message: error.to_string(),\n        }\n    }\n}\n\nfn main() -> Result<(), AppError> {\n    let mut file = File::open("hello_world.txt")?;\n\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n\n    let _number: usize;\n    _number = content.parse()?;\n\n    Ok(())\n}\n\n// --------------- \u4e0a\u8ff0\u4ee3\u7801\u8fd0\u884c\u540e\u7684\u53ef\u80fd\u8f93\u51fa ---------------\n// 01. \u82e5 hello_world.txt \u6587\u4ef6\u4e0d\u5b58\u5728\n// Error: AppError { kind: "io", message: "No such file or directory" }\n// 02. \u82e5\u7528\u6237\u6ca1\u6709\u76f8\u5173\u7684\u6743\u9650\u8bbf\u95ee hello_world.txt\n// Error: AppError { kind: "io", message: "Permission denied" }\n// 03. \u82e5 hello_world.txt \u5305\u542b\u6709\u975e\u6570\u5b57\u7684\u5185\u5bb9\uff0c\u4f8b\u5982 Hello, world!\n// Error: AppError { kind: "parse", message: "invalid digit found in string" }\n'})}),"\n",(0,t.jsx)(e.h2,{id:"format-print",children:"Format Print"}),"\n",(0,t.jsx)(e.h3,{id:"format-print-macros",children:"Format Print Macros"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"print!"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"println!"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"eprint!"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"eprintln!"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"format!"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'println!("Hello");                 // => "Hello"\nprintln!("Hello, {}!", "world");   // => "Hello, world!"\nprintln!("The number is {}", 1);   // => "The number is 1"\nprintln!("{:?}", (3, 4));          // => "(3, 4)"\nprintln!("{value}", value=4);      // => "4"\nprintln!("{} {}", 1, 2);           // => "1 2"\nprintln!("{:04}", 42);             // => "0042" with leading zeros\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s = "hello";\n    println!("{}, world", s);\n    let s1 = format!("{}, world", s);\n    print!("{}", s1);\n    print!("{}\\n", "!");\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"format-print-placeholder",children:"Format Print Placeholder"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"{}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"{:?}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"{:#?}"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"Index placeholder."}),"\n",(0,t.jsx)(e.li,{children:"Alias placeholder."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    println!("{1}{}{0}{}", 1, 2); // => 2112\n    println!("{name} {}", 1, name = 2); // => "2 1"\n    println!("{a} {c} {b}", a = "a", b = \'b\', c = 3); // => "a 3 b"\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pad placeholder."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // \u4ee5\u4e0b\u5168\u90e8\u8f93\u51fa "Hello x    !"\n    // \u4e3a"x"\u540e\u9762\u586b\u5145\u7a7a\u683c, \u8865\u9f50\u5bbd\u5ea65\n    println!("Hello {:5}!", "x");\n    // \u4f7f\u7528\u53c2\u65705\u6765\u6307\u5b9a\u5bbd\u5ea6\n    println!("Hello {:1$}!", "x", 5);\n    // \u4f7f\u7528x\u4f5c\u4e3a\u5360\u4f4d\u7b26\u8f93\u51fa\u5185\u5bb9, \u540c\u65f6\u4f7f\u75285\u4f5c\u4e3a\u5bbd\u5ea6\n    println!("Hello {1:0$}!", 5, "x");\n    // \u4f7f\u7528\u6709\u540d\u79f0\u7684\u53c2\u6570\u4f5c\u4e3a\u5bbd\u5ea6\n    println!("Hello {:width$}!", "x", width = 5);\n\n    // \u4f7f\u7528\u53c2\u65705\u4e3a\u53c2\u6570x\u6307\u5b9a\u5bbd\u5ea6, \u540c\u65f6\u5728\u7ed3\u5c3e\u8f93\u51fa\u53c2\u65705 => Hello x    !5\n    println!("Hello {:1$}!{}", "x", 5);\n\n    // \u5bbd\u5ea6\u662f5 => Hello     5!\n    println!("Hello {:5}!", 5);\n    // \u663e\u5f0f\u7684\u8f93\u51fa\u6b63\u53f7 => Hello +5!\n    println!("Hello {:+}!", 5);\n    // \u5bbd\u5ea65, \u4f7f\u75280\u8fdb\u884c\u586b\u5145 => Hello 00005!\n    println!("Hello {:05}!", 5);\n    // \u8d1f\u53f7\u4e5f\u8981\u5360\u7528\u4e00\u4f4d\u5bbd\u5ea6 => Hello -0005!\n    println!("Hello {:05}!", -5);\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Alignment placeholder."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // \u4ee5\u4e0b\u5168\u90e8\u90fd\u4f1a\u8865\u9f505\u4e2a\u5b57\u7b26\u7684\u957f\u5ea6\n    // \u5de6\u5bf9\u9f50 => Hello x    !\n    println!("Hello {:<5}!", "x");\n    // \u53f3\u5bf9\u9f50 => Hello     x\n    println!("Hello {:>5}!", "x");\n    // \u5c45\u4e2d\u5bf9\u9f50 => Hello   x  !\n    println!("Hello {:^5}!", "x");\n\n    // \u5bf9\u9f50\u5e76\u4f7f\u7528\u6307\u5b9a\u7b26\u53f7\u586b\u5145 => Hello x&&&&!\n    // \u6307\u5b9a\u7b26\u53f7\u586b\u5145\u7684\u524d\u63d0\u6761\u4ef6\u662f\u5fc5\u987b\u6709\u5bf9\u9f50\u5b57\u7b26\n    println!("Hello {:&<5}!", "x");\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Precision placeholder."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let v = 3.1415926;\n    // \u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d => 3.14\n    println!("{:.2}", v);\n    // \u5e26\u7b26\u53f7\u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d => +3.14\n    println!("{:+.2}", v);\n    // \u4e0d\u5e26\u5c0f\u6570 => 3\n    println!("{:.0}", v);\n    // \u901a\u8fc7\u53c2\u6570\u6765\u8bbe\u5b9a\u7cbe\u5ea6 => 3.1416, \u76f8\u5f53\u4e8e{:.4}\n    println!("{:.1$}", v, 4);\n\n    let s = "hello I\'m some one";\n    // \u4fdd\u7559\u5b57\u7b26\u4e32\u524d\u4e09\u4e2a\u5b57\u7b26 => hel\n    println!("{:.3}", s);\n    // {:.*} \u63a5\u6536\u4e24\u4e2a\u53c2\u6570, \u7b2c\u4e00\u4e2a\u662f\u7cbe\u5ea6, \u7b2c\u4e8c\u4e2a\u662f\u88ab\u683c\u5f0f\u5316\u7684\u503c => Hello abc!\n    println!("Hello {:.*}!", 3, "abcdefg");\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Radix placeholder: ",(0,t.jsx)(e.code,{children:"boxXeE"}),".","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fmt::Binary"})," trait."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fmt::Octal"})," trait."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fmt::LowerHex"})," trait."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fmt::UpperHex"})," trait."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fmt::LowerExp"})," trait."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fmt::UpperExp"})," trait."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // \u4e8c\u8fdb\u5236 => 0b11011!\n    println!("{:#b}!", 27);\n    // \u516b\u8fdb\u5236 => 0o33!\n    println!("{:#o}!", 27);\n    // \u5341\u8fdb\u5236 => 27!\n    println!("{}!", 27);\n    // \u5c0f\u5199\u5341\u516d\u8fdb\u5236 => 0x1b!\n    println!("{:#x}!", 27);\n    // \u5927\u5199\u5341\u516d\u8fdb\u5236 => 0x1B!\n    println!("{:#X}!", 27);\n\n    // \u4e0d\u5e26\u524d\u7f00\u7684\u5341\u516d\u8fdb\u5236 => 1b!\n    println!("{:x}!", 27);\n\n    // \u4f7f\u75280\u586b\u5145\u4e8c\u8fdb\u5236, \u5bbd\u5ea6\u4e3a10 => 0b00011011!\n    println!("{:#010b}!", 27);\n\n    println!("{:2e}", 1000000000); // => 1e9\n    println!("{:2E}", 1000000000); // => 1E9\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"debug-trait",children:"Debug Trait"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: u8\n}\n\nfn main() {\n    let i = 3.1415926;\n    let s = String::from("hello");\n    let v = vec![1, 2, 3];\n    let p = Person{name: "name".to_string(), age: 18};\n    println!("{:?}, {:?}, {:?}, {:?}", i, s, v, p);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"display-trait",children:"Display Trait"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fmt;\n\nstruct Person {\n    name: String,\n    age: u8,\n}\n\nimpl fmt::Display for Person {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            "My name is {}, {} year old.",\n            self.name, self.age\n        )\n    }\n}\n\nfn main() {\n    let p = Person {\n        name: "name".to_string(),\n        age: 18,\n    };\n\n    println!("{}", p);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"lifetime",children:"Lifetime"}),"\n",(0,t.jsxs)(e.p,{children:["\u663e\u5f0f\u5730\u4f7f\u7528\u751f\u547d\u5468\u671f, \u53ef\u4ee5\u8ba9\u7f16\u8bd1\u5668\u6b63\u786e\u5730\u8ba4\u8bc6\u5230\u591a\u4e2a",(0,t.jsx)(e.strong,{children:"\u5f15\u7528"}),"\u4e4b\u95f4\u7684\u5173\u7cfb."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"&i32        // \u4e00\u4e2a\u5f15\u7528\n&'a i32     // \u5177\u6709\u663e\u5f0f\u751f\u547d\u5468\u671f\u7684\u5f15\u7528\n&'a mut i32 // \u5177\u6709\u663e\u5f0f\u751f\u547d\u5468\u671f\u7684\u53ef\u53d8\u5f15\u7528\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"function-lifetime",children:"Function Lifetime"}),"\n",(0,t.jsxs)(e.p,{children:["\u51fd\u6570\u6216\u8005\u65b9\u6cd5\u4e2d,\n\u53c2\u6570\u7684\u751f\u547d\u5468\u671f\u88ab\u79f0\u4e3a",(0,t.jsx)(e.code,{children:"\u8f93\u5165\u751f\u547d\u5468\u671f"}),",\n\u8fd4\u56de\u503c\u7684\u751f\u547d\u5468\u671f\u88ab\u79f0\u4e3a",(0,t.jsx)(e.code,{children:"\u8f93\u51fa\u751f\u547d\u5468\u671f"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u6bcf\u4e00\u4e2a\u5f15\u7528\u53c2\u6570\u90fd\u4f1a\u83b7\u5f97\u72ec\u81ea\u7684\u751f\u547d\u5468\u671f:\n",(0,t.jsx)(e.code,{children:"fn foo<'a, 'b>(x: &'a i32, y: &'b i32)"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u82e5\u53ea\u6709\u4e00\u4e2a\u8f93\u5165\u751f\u547d\u5468\u671f, \u5219\u8be5\u751f\u547d\u5468\u671f\u4f1a\u88ab\u8d4b\u7ed9\u6240\u6709\u8f93\u51fa\u751f\u547d\u5468\u671f."}),"\n",(0,t.jsxs)(e.li,{children:["\u82e5\u5b58\u5728\u591a\u4e2a\u8f93\u5165\u751f\u547d\u5468\u671f, \u4e14\u5176\u4e2d\u4e00\u4e2a\u662f",(0,t.jsx)(e.code,{children:"&self"}),"/",(0,t.jsx)(e.code,{children:"&mut self"}),",\n\u5219",(0,t.jsx)(e.code,{children:"&self"}),"\u751f\u547d\u5468\u671f\u88ab\u8d4b\u7ed9\u6240\u6709\u8f93\u51fa\u751f\u547d\u5468\u671f (\u9664\u975e\u663e\u5f0f\u5730\u58f0\u660e\u8f93\u51fa\u751f\u547d\u5468\u671f)."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"static-lifetime",children:"Static Lifetime"}),"\n",(0,t.jsxs)(e.p,{children:["\u751f\u547d\u5468\u671f",(0,t.jsx)(e.code,{children:"'static"}),"\u8868\u793a\u6301\u7eed\u6574\u4e2a\u7a0b\u5e8f,\n\u4f8b\u5982\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u548c\u7279\u5f81\u5bf9\u8c61."]}),"\n",(0,t.jsx)(e.h3,{id:"lifetime-constraint",children:"Lifetime Constraint"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"'a: 'b"}),": ",(0,t.jsx)(e.code,{children:"'a"})," \u751f\u547d\u5468\u671f\u66f4\u957f."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"T: 'a"}),": ",(0,t.jsx)(e.code,{children:"T"})," \u751f\u547d\u5468\u671f\u66f4\u957f."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"closure",children:"Closure"}),"\n",(0,t.jsx)(e.h3,{id:"function-parameter-closure",children:"Function Parameter Closure"}),"\n",(0,t.jsx)(e.p,{children:"\u6539\u53d8\u6355\u83b7\u53d8\u91cf\u7684\u6240\u6709\u6743 (FnOnce):"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn fn_once<F>(func: F)\nwhere\n    F: FnOnce(usize) -> bool + Copy,\n{\n    println!("{}", func(3));\n    println!("{}", func(4));\n}\n\nfn main() {\n    let x = vec![1, 2, 3];\n    fn_once(|z|{z == x.len()})\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"\u53ef\u53d8\u501f\u7528\u6355\u83b7 (FnMut):"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::new();\n\n    let update_string =  |str| s.push_str(str);\n\n    exec(update_string);\n\n    println!("{:?}",s);\n}\n\nfn exec<\'a, F: FnMut(&\'a str)>(mut f: F)  {\n    f("hello")\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"\u4e0d\u53ef\u53d8\u501f\u7528\u6355\u83b7 (Fn):"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s = "hello, ".to_string();\n\n    let update_string =  |str| println!("{},{}",s,str);\n\n    exec(update_string);\n\n    println!("{:?}",s);\n}\n\nfn exec<\'a, F: Fn(String) -> ()>(f: F)  {\n    f("world".to_string())\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u6240\u6709\u95ed\u5305\u90fd\u81ea\u52a8\u5b9e\u73b0\u4e86 ",(0,t.jsx)(e.code,{children:"FnOnce"})," \u7279\u5f81, \u56e0\u6b64\u4efb\u4f55\u4e00\u4e2a\u95ed\u5305\u90fd\u81f3\u5c11\u53ef\u4ee5\u88ab\u8c03\u7528\u4e00\u6b21."]}),"\n",(0,t.jsxs)(e.li,{children:["\u6ca1\u6709\u79fb\u51fa\u6240\u6355\u83b7\u53d8\u91cf\u7684\u6240\u6709\u6743\u7684\u95ed\u5305\u81ea\u52a8\u5b9e\u73b0\u4e86 ",(0,t.jsx)(e.code,{children:"FnMut"})," \u7279\u5f81."]}),"\n",(0,t.jsxs)(e.li,{children:["\u4e0d\u9700\u8981\u5bf9\u6355\u83b7\u53d8\u91cf\u8fdb\u884c\u6539\u53d8\u7684\u95ed\u5305\u81ea\u52a8\u5b9e\u73b0\u4e86 ",(0,t.jsx)(e.code,{children:"Fn"})," \u7279\u5f81."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"function-return-closure",children:"Function Return Closure"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn factory() -> impl Fn(i32) -> i32 {\n    let num = 5;\n    |x| x + num\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {\n    let num = 5;\n\n    if x > 1{\n        Box::new(move |x| x + num)\n    } else {\n        Box::new(move |x| x - num)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"iterator",children:"Iterator"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let arr = [1, 2, 3];\n\nfor v in arr.into_iter() {\n    println!("{}", v);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn main() {\n    let arr = [1, 2, 3];\n    let mut arr_iter = arr.into_iter();\n\n    assert_eq!(arr_iter.next(), Some(1));\n    assert_eq!(arr_iter.next(), Some(2));\n    assert_eq!(arr_iter.next(), Some(3));\n    assert_eq!(arr_iter.next(), None);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"iterator-trait",children:"Iterator Trait"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"pub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n\nimpl<I: Iterator> IntoIterator for I {\n    type Item = I::Item;\n    type IntoIter = I;\n\n    #[inline]\n    fn into_iter(self) -> I {\n        self\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"iter"}),": \u4e0d\u53ef\u53d8\u501f\u7528."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"iter_mut"}),": \u53ef\u53d8\u501f\u7528."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"into_iter"}),": \u6539\u53d8\u6240\u6709\u6743."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn iter(&self) -> Iter             // Iter implements Iterator<Item = &U>\nfn iter_mut(&mut self) -> IterMut  // IterMut implements Iterator<Item = &mut U>\nfn into_iter(self) -> IntoIter     // IntoIter implements Iterator<Item = U>\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let values = vec![1, 2, 3];\n\n    for v in values.into_iter() {\n        println!("{}", v)\n    }\n\n    // \u4e0b\u9762\u7684\u4ee3\u7801\u5c06\u62a5\u9519.\n    // println!("{:?}",values);\n\n    let values = vec![1, 2, 3];\n    let _values_iter = values.iter();\n\n    // \u4e0d\u4f1a\u62a5\u9519.\n    println!("{:?}", values);\n\n    let mut values = vec![1, 2, 3];\n    // \u5bf9 values \u4e2d\u7684\u5143\u7d20\u8fdb\u884c\u53ef\u53d8\u501f\u7528.\n    let mut values_iter_mut = values.iter_mut();\n\n    // \u53d6\u51fa\u7b2c\u4e00\u4e2a\u5143\u7d20, \u5e76\u4fee\u6539\u4e3a0.\n    if let Some(v) = values_iter_mut.next() {\n        *v = 0;\n    }\n\n    // \u8f93\u51fa [0, 2, 3].\n    println!("{:?}", values);\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Implement iterator:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -> Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.count < 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n\nfn main() {\n    let mut counter = Counter::new();\n    assert_eq!(counter.next(), Some(1));\n    assert_eq!(counter.next(), Some(2));\n    assert_eq!(counter.next(), Some(3));\n    assert_eq!(counter.next(), Some(4));\n    assert_eq!(counter.next(), Some(5));\n    assert_eq!(counter.next(), None);\n\n    let sum: u32 = Counter::new()\n        .zip(Counter::new().skip(1))\n        .map(|(a, b)| a * b)\n        .filter(|x| x % 3 == 0)\n        .sum();\n    assert_eq!(18, sum);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"adapter-methods",children:"Adapter Methods"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u6d88\u8d39\u6027\u9002\u914d\u5668: \u83b7\u53d6\u8fed\u4ee3\u5668\u7684\u6240\u6709\u6743, \u5e76\u6d88\u8017\u8fed\u4ee3\u5668\u4e2d\u6240\u6709\u5143\u7d20.","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"collect::<T>()"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"fold."}),"\n",(0,t.jsx)(e.li,{children:"partition."}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"sum::<T>()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\u8fed\u4ee3\u6027\u9002\u914d\u5668: \u60f0\u6027\u65b9\u6cd5 (Lazy Iterator)","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"enumerate."}),"\n",(0,t.jsx)(e.li,{children:"filter."}),"\n",(0,t.jsx)(e.li,{children:"filter_map."}),"\n",(0,t.jsx)(e.li,{children:"map."}),"\n",(0,t.jsx)(e.li,{children:"take_while."}),"\n",(0,t.jsx)(e.li,{children:"zip."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Ordinary iterator methods:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Iterator::any."}),"\n",(0,t.jsx)(e.li,{children:"Iterator::find."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["More adapter methods see ",(0,t.jsx)(e.code,{children:"Iterator"})," trait\n",(0,t.jsx)(e.a,{href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html",children:"documentation"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let v1 = vec![1, 2, 3];\n    let v1_iter = v1.iter();\n    let total: i32 = v1_iter.sum();\n    assert_eq!(total, 6);\n\n    // v1_iter \u662f\u501f\u7528\u4e86 v1, \u56e0\u6b64 v1 \u53ef\u4ee5\u7167\u5e38\u4f7f\u7528.\n    println!("{:?}",v1);\n\n    // \u4ee5\u4e0b\u4ee3\u7801\u4f1a\u62a5\u9519, \u56e0\u4e3a `sum` \u62ff\u5230\u4e86\u8fed\u4ee3\u5668 `v1_iter` \u7684\u6240\u6709\u6743.\n    // println!("{:?}",v1_iter);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn main() {\n    let v1: Vec<i32> = vec![1, 2, 3];\n    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n    assert_eq!(v2, vec![2, 3, 4]);\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::collections::HashMap;\n\nfn main() {\n    let names = ["name1", "name2"];\n    let ages = [18, 18];\n    let folks: HashMap<_, _> = names.into_iter().zip(ages.into_iter()).collect();\n    println!("{:?}",folks);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"smart-pointer",children:"Smart Pointer"}),"\n",(0,t.jsx)(e.h3,{id:"box-type",children:"Box Type"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Box<T>"})," \u5c06\u4e00\u4e2a\u503c\u5206\u914d\u5230\u5806\u4e0a, \u7136\u540e\u5728\u6808\u4e0a\u4fdd\u7559\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u5806\u4e0a\u6570\u636e:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u5b9e\u73b0\u8f6c\u79fb\u6240\u6709\u6743\u65f6\u7684\u96f6\u62f7\u8d1d."}),"\n",(0,t.jsx)(e.li,{children:"\u5c06\u4e0d\u5b9a\u957f\u7c7b\u578b\u8f6c\u6362\u4e3a\u5b9a\u957f\u7c7b\u578b."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // \u5728\u6808\u4e0a\u521b\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a 1000 \u7684\u6570\u7ec4.\n    let arr = [0;1000];\n    // \u5c06 arr \u6240\u6709\u6743\u8f6c\u79fb arr1, \u7531\u4e8e `arr` \u5206\u914d\u5728\u6808\u4e0a, \u56e0\u6b64\u76f4\u63a5\u91cd\u65b0\u6df1\u62f7\u8d1d\u4e86\u4e00\u4efd\u6570\u636e.\n    let arr1 = arr;\n\n    // arr \u548c arr1 \u90fd\u62e5\u6709\u5404\u81ea\u7684\u6808\u4e0a\u6570\u7ec4, \u56e0\u6b64\u4e0d\u4f1a\u62a5\u9519.\n    println!("{:?}", arr.len());\n    println!("{:?}", arr1.len());\n\n    // \u5728\u5806\u4e0a\u521b\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a 1000 \u7684\u6570\u7ec4, \u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u5b83.\n    let arr = Box::new([0;1000]);\n    // \u5c06\u5806\u4e0a\u6570\u7ec4\u7684\u6240\u6709\u6743\u8f6c\u79fb\u7ed9 arr1, \u7531\u4e8e\u6570\u636e\u5728\u5806\u4e0a, \u56e0\u6b64\u4ec5\u4ec5\u62f7\u8d1d\u4e86\u667a\u80fd\u6307\u9488\u7684\u7ed3\u6784\u4f53, \u5e95\u5c42\u6570\u636e\u5e76\u6ca1\u6709\u88ab\u62f7\u8d1d.\n    // \u6240\u6709\u6743\u987a\u5229\u8f6c\u79fb\u7ed9 arr1, arr \u4e0d\u518d\u62e5\u6709\u6240\u6709\u6743.\n    let arr1 = arr;\n    println!("{:?}", arr1.len());\n    // \u7531\u4e8e arr \u4e0d\u518d\u62e5\u6709\u5e95\u5c42\u6570\u7ec4\u7684\u6240\u6709\u6743, \u56e0\u6b64\u4e0b\u9762\u4ee3\u7801\u5c06\u62a5\u9519.\n    // println!("{:?}", arr.len());\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"deref-trait",children:"Deref Trait"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&smart_pointer"}),"\n=> ",(0,t.jsx)(e.code,{children:"smart_pointer.defer()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"*smart_pointer"}),"\n=> ",(0,t.jsx)(e.code,{children:"*(smart_pointer.defer())"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"smart_pointer.method()"}),"\n=> ",(0,t.jsx)(e.code,{children:"(&smart_pointer).method()"}),"\n=> ",(0,t.jsx)(e.code,{children:"(smart_pointer.defer()).method()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: Deref<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&T => &U"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: DerefMut<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&mut T => &mut U"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: Deref<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&mut T => &U"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use core::ops::{self};\nuse crate::str::{self, from_boxed_utf8_unchecked};\nuse crate::vec::Vec;\n\nstruct String {\n    vec: Vec<u8>,\n}\n\nimpl ops::Deref for String {\n    type Target = str;\n\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> ops::Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn main() {\n    let x = MyBox::new(5);\n    assert_eq!(5, *x);\n    // => *(x.deref())\n    // => *(&x.0)\n    // => x.0\n\n    let s = MyBox::new(String::from("hello world"));\n    display(&s);\n    // => &MyBox\n    // => MyBox.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n\n    let hello_world = MyBox::new(String::from("hello, world"));\n    let s1: &str = &hello_world;\n    // => &MyBox<String>\n    // => MyBox<String>.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n    let s2: String = hello_world.to_string();\n    // => MyBox<String>.to_string()\n    // => (&MyBox<String>).to_string()\n    // => (MyBox<String>.defer()).to_string()\n    // => (&String).to_string()\n    let ptr: *const u8 = hello_world.as_ptr();\n    // => MyBox<String>.as_ptr()\n    // => (&MyBox<String>).as_ptr()\n    // => (MyBox<String>.defer()).as_ptr()\n    // => (&String).as_ptr()\n    // => (String.defer()).as_ptr()\n    // => (&str).as_ptr()\n}\n\nfn display(s: &str) {\n    println!("{}", s);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"drop-trait",children:"Drop Trait"}),"\n",(0,t.jsx)(e.p,{children:"Drop order:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u53d8\u91cf\u7ea7\u522b, \u6309\u7167\u9006\u5e8f\u7684\u65b9\u5f0f, \u5148\u521b\u5efa\u7684\u53d8\u91cf\u540e drop."}),"\n",(0,t.jsx)(e.li,{children:"\u7ed3\u6784\u4f53\u5185\u90e8, \u6309\u7167\u987a\u5e8f\u7684\u65b9\u5f0f, \u7ed3\u6784\u4f53\u4e2d\u7684\u5b57\u6bb5\u6309\u7167\u5b9a\u4e49\u4e2d\u7684\u987a\u5e8f\u4f9d\u6b21 drop."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"reference-counting-type",children:"Reference Counting Type"}),"\n",(0,t.jsx)(e.p,{children:"\u901a\u8fc7\u5f15\u7528\u8ba1\u6570\u7684\u65b9\u5f0f, \u5141\u8bb8\u4e00\u4e2a\u6570\u636e\u8d44\u6e90\u5728\u540c\u4e00\u65f6\u523b\u62e5\u6709\u591a\u4e2a\u6240\u6709\u8005."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(String::from("hello, world"));\n    let b = Rc::clone(&a); // \u590d\u5236\u4e86\u667a\u80fd\u6307\u9488\u5e76\u589e\u52a0\u4e86\u5f15\u7528\u8ba1\u6570, \u5e76\u6ca1\u6709\u514b\u9686\u5e95\u5c42\u6570\u636e.\n    assert_eq!(2, Rc::strong_count(&a));\n    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc"}),"/",(0,t.jsx)(e.code,{children:"Arc"})," \u662f\u4e0d\u53ef\u53d8\u5f15\u7528, \u65e0\u6cd5\u4fee\u6539\u5b83\u6307\u5411\u7684\u503c."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc<T>"})," \u662f\u4e00\u4e2a\u667a\u80fd\u6307\u9488, \u5b9e\u73b0\u4e86 ",(0,t.jsx)(e.code,{children:"Deref"})," \u7279\u5f81, \u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 ",(0,t.jsx)(e.code,{children:"T"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u4e00\u65e6\u6700\u540e\u4e00\u4e2a\u62e5\u6709\u8005\u6d88\u5931, \u5219\u8d44\u6e90\u4f1a\u81ea\u52a8\u88ab\u56de\u6536."}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Arc"}),": Atomic reference counting."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let s = Arc::new(String::from("Multiple threads walker"));\n\n    for _ in 0..10 {\n        let s = Arc::clone(&s);\n        let handle = thread::spawn(move || {\n           println!("{}", s)\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"cell-and-refcell-type",children:"Cell and RefCell Type"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Cell"})," for copyable type."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::Cell;\n\nfn main() {\n    let c = Cell::new("abc");\n    let one = c.get();\n    c.set("xyz");\n    let two = c.get();\n    println!("{}, {}", one, two); // abc, xyz\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::cell::Cell;\n\nfn retain_even(nums: &mut Vec<i32>) {\n    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])\n        .as_slice_of_cells();\n\n    let mut i = 0;\n\n    for num in slice.iter().filter(|num| is_even(num.get())) {\n        slice[i].set(num.get());\n        i += 1;\n    }\n\n    nums.truncate(i);\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"RefCell"})," for borrowing reference:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u5b9e\u73b0\u5185\u90e8\u53ef\u53d8\u6027: \u4e0d\u53ef\u53d8\u503c\u7684\u53ef\u53d8\u501f\u7528.\n",(0,t.jsx)(e.code,{children:"imut_self.refcell_member.borrow_mut().changeMember()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc<RefCell<T>>"}),": \u5b9e\u73b0\u591a\u4e2a\u53ef\u53d8\u6570\u636e\u6240\u6709\u8005."]}),"\n",(0,t.jsxs)(e.li,{children:["\u5b9e\u73b0\u7f16\u8bd1\u671f",(0,t.jsx)(e.strong,{children:"\u53ef\u53d8\u501f\u7528"}),"\u4e0e",(0,t.jsx)(e.strong,{children:"\u4e0d\u53ef\u53d8\u501f\u7528"}),"\u5171\u5b58,\n\u4f46\u4f1a\u5f15\u8d77\u8fd0\u884c\u65f6 ",(0,t.jsx)(e.code,{children:"panic"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\n\nfn main() {\n    let s = RefCell::new(String::from("hello, world"));\n    let s1 = s.borrow();\n    let s2 = s.borrow_mut();\n\n    println!("{}, {}", s1, s2);\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["\u901a\u8fc7\u5305\u88f9\u4e00\u5c42 ",(0,t.jsx)(e.code,{children:"RefCell"}),",\n\u5c06\u4e0d\u53ef\u53d8\u501f\u7528 ",(0,t.jsx)(e.code,{children:"&self"})," \u7684\u6210\u5458\u6210\u4e3a\u4e00\u4e2a\u53ef\u53d8\u503c,\n\u7136\u540e\u5b9e\u73b0\u4fee\u6539:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\n\npub trait Messenger {\n    fn send(&self, msg: String);\n}\n\npub struct MsgQueue {\n    msg_cache: RefCell<Vec<String>>,\n}\n\nimpl Messenger for MsgQueue {\n    fn send(&self, msg: String) {\n        self.msg_cache.borrow_mut().push(msg)\n    }\n}\n\nfn main() {\n    let mq = MsgQueue {\n        msg_cache: RefCell::new(Vec::new()),\n    };\n    mq.send("hello, world".to_string());\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"circle-reference",children:"Circle Reference"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Weak"})," \u901a\u8fc7 ",(0,t.jsx)(e.code,{children:"use std::rc::Weak"})," \u5f15\u5165, \u5177\u6709\u4ee5\u4e0b\u7279\u70b9:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u53ef\u8bbf\u95ee, \u4f46\u6ca1\u6709\u6240\u6709\u6743, \u4e0d\u589e\u52a0\u5f15\u7528\u8ba1\u6570, \u4e0d\u5f71\u54cd drop."}),"\n",(0,t.jsxs)(e.li,{children:["\u53ef\u7531 ",(0,t.jsx)(e.code,{children:"Rc<T>"})," \u8c03\u7528 ",(0,t.jsx)(e.code,{children:"downgrade"})," \u65b9\u6cd5\u8f6c\u6362\u6210 ",(0,t.jsx)(e.code,{children:"Weak<T>"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Weak<T>"})," \u53ef\u4f7f\u7528 ",(0,t.jsx)(e.code,{children:"upgrade"})," \u65b9\u6cd5\u8f6c\u6362\u6210 ",(0,t.jsx)(e.code,{children:"Option<Rc<T>>"}),",\n\u5982\u679c\u8d44\u6e90\u5df2\u7ecf\u88ab\u91ca\u653e, \u5219 ",(0,t.jsx)(e.code,{children:"Option"})," \u7684\u503c\u662f ",(0,t.jsx)(e.code,{children:"None"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u5e38\u7528\u4e8e\u89e3\u51b3\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            "branch strong = {}, weak = {}",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            "leaf strong = {}, weak = {}",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"phantom-type",children:"Phantom Type"}),"\n",(0,t.jsxs)(e.p,{children:["\u865a\u7c7b\u578b/\u5e7d\u7075\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u79cd\u5728",(0,t.jsx)(e.strong,{children:"\u8fd0\u884c\u65f6\u4e0d\u51fa\u73b0"}),",\n\u4ec5\u8fdb\u884c",(0,t.jsx)(e.strong,{children:"\u9759\u6001\u7f16\u8bd1\u68c0\u67e5"}),"\u7684\u7c7b\u578b\u53c2\u6570."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::marker::PhantomData;\n\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: PhantomData<&'a T>,\n}\n\nstruct Vec<T> {\n    data: *const T,\n    len: usize,\n    cap: usize,\n    _marker: PhantomData<T>,\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::marker::PhantomData;\n\n#[derive(PartialEq)]\nstruct PhantomTuple<A, B>(A, PhantomData<B>);\n\n#[derive(PartialEq)]\nstruct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }\n\nfn main() {\n    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);\n    let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);\n\n    let _struct1: PhantomStruct<char, f32> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    let _struct2: PhantomStruct<char, f64> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef\uff01\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u4e9b\u503c\u4e0d\u80fd\u591f\u6bd4\u8f83\uff1a\n    println!(\"_tuple1 == _tuple2 yields: {}\",\n              _tuple1 == _tuple2);\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef\uff01\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u4e9b\u503c\u4e0d\u80fd\u591f\u6bd4\u8f83\uff1a\n    println!(\"_struct1 == _struct2 yields: {}\",\n              _struct1 == _struct2);\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::ops::Add;\nuse std::marker::PhantomData;\n\n#[derive(Debug, Clone, Copy)]\nenum Inch {}\n#[derive(Debug, Clone, Copy)]\nenum Mm {}\n\n#[derive(Debug, Clone, Copy)]\nstruct Length<Unit>(f64, PhantomData<Unit>);\n\nimpl<Unit> Add for Length<Unit> {\n     type Output = Length<Unit>;\n\n    fn add(self, rhs: Length<Unit>) -> Length<Unit> {\n        Length(self.0 + rhs.0, PhantomData)\n    }\n}\n\nfn main() {\n    let one_foot:  Length<Inch> = Length(12.0, PhantomData);\n    let one_meter: Length<Mm>   = Length(1000.0, PhantomData);\n\n    let two_feet = one_foot + one_foot;\n    let two_meters = one_meter + one_meter;\n\n    println!("one foot + one_foot = {:?} in", two_feet.0);\n    println!("one meter + one_meter = {:?} mm", two_meters.0);\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef: \u7c7b\u578b\u4e0d\u5339\u914d.\n    let compile_error = one_foot + one_meter;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"concurrent-programming",children:"Concurrent Programming"}),"\n",(0,t.jsx)(e.h3,{id:"concurrency-programming-model",children:"Concurrency Programming Model"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Name"}),(0,t.jsx)(e.th,{children:"Pros"}),(0,t.jsx)(e.th,{children:"Cons"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"OS Thread"}),(0,t.jsx)(e.td,{children:"simple, native model"}),(0,t.jsx)(e.td,{children:"consistent and context switch overhead"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Event Driven"}),(0,t.jsx)(e.td,{children:"perf model"}),(0,t.jsx)(e.td,{children:"non-liner logic, callback hell"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Coroutines"}),(0,t.jsx)(e.td,{children:"perf model"}),(0,t.jsx)(e.td,{children:"non-system abstraction"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Actor"}),(0,t.jsx)(e.td,{children:"distributed model"}),(0,t.jsx)(e.td,{children:"complex flow control and retry logic"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Async/Await"}),(0,t.jsx)(e.td,{children:"perf, native model"}),(0,t.jsx)(e.td,{children:"complex internal logic"})]})]})]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"OS Threads"})," for CPU intensive task (parallel computing),\n",(0,t.jsx)(e.code,{children:"Async/Await"})," for I/O intensive task (blocking I/O)."]}),"\n",(0,t.jsx)(e.h3,{id:"threads",children:"Threads"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..5 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"barrier",children:"Barrier"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::{Arc, Barrier};\nuse std::thread;\n\nfn main() {\n    let mut handles = Vec::with_capacity(6);\n    let barrier = Arc::new(Barrier::new(6));\n\n    for _ in 0..6 {\n        let b = barrier.clone();\n        handles.push(thread::spawn(move|| {\n            println!("before wait");\n            b.wait();\n            println!("after wait");\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"condition-variables-and-mutex",children:"Condition Variables and Mutex"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::thread;\nuse std::sync::{Arc, Mutex, Condvar};\n\nfn main() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair2 = pair.clone();\n\n    thread::spawn(move|| {\n        let &(ref lock, ref cvar) = &*pair2;\n        let mut started = lock.lock().unwrap();\n        println!("changing started");\n        *started = true;\n        cvar.notify_one();\n    });\n\n    let &(ref lock, ref cvar) = &*pair;\n    let mut started = lock.lock().unwrap();\n    while !*started {\n        started = cvar.wait(started).unwrap();\n    }\n\n    println!("started changed");\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!("Result: {}", *counter.lock().unwrap());\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Read and write mutex:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u540c\u65f6\u5141\u8bb8\u591a\u4e2a\u8bfb, \u4f46\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2a\u5199."}),"\n",(0,t.jsx)(e.li,{children:"\u8bfb\u548c\u5199\u4e0d\u80fd\u540c\u65f6\u5b58\u5728."}),"\n",(0,t.jsxs)(e.li,{children:["\u53ef\u4ee5\u4f7f\u7528 ",(0,t.jsx)(e.code,{children:"read"}),"/",(0,t.jsx)(e.code,{children:"try_read"}),"/",(0,t.jsx)(e.code,{children:"write"}),"/",(0,t.jsx)(e.code,{children:"try_write"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::sync::RwLock;\n\nfn main() {\n    let lock = RwLock::new(5);\n\n    // \u540c\u4e00\u65f6\u95f4\u5141\u8bb8\u591a\u4e2a\u8bfb.\n    {\n        let r1 = lock.read().unwrap();\n        let r2 = lock.read().unwrap();\n        assert_eq!(*r1, 5);\n        assert_eq!(*r2, 5);\n    } // Drop.\n\n    // \u540c\u4e00\u65f6\u95f4\u53ea\u5141\u8bb8\u4e00\u4e2a\u5199.\n    {\n        let mut w = lock.write().unwrap();\n        *w += 1;\n        assert_eq!(*w, 6);\n    } // Drop.\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"threads-communication",children:"Threads Communication"}),"\n",(0,t.jsx)(e.p,{children:"Message channel:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        tx.send(1).unwrap();\n    });\n\n    // Block.\n    println!("receive {}", rx.recv().unwrap());\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Sync channel with message buffer:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // Sync channel with 3 length buffer.\n    let (tx, rx)= mpsc::sync_channel(3);\n\n    let handle = thread::spawn(move || {\n        println!("\u53d1\u9001\u4e4b\u524d");\n        tx.send(1).unwrap();\n        println!("\u53d1\u9001\u4e4b\u540e");\n    });\n\n    println!("\u7761\u7720\u4e4b\u524d");\n    thread::sleep(Duration::from_secs(3));\n    println!("\u7761\u7720\u4e4b\u540e");\n\n    println!("receive {}", rx.recv().unwrap());\n    handle.join().unwrap();\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["Send message via ",(0,t.jsx)(e.code,{children:"for"})," loop:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let values = vec![\n            String::from("hi"),\n            String::from("from"),\n            String::from("the"),\n            String::from("thread"),\n        ];\n\n        for value in values {\n            tx.send(value).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Multiple producers:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let tx1 = tx.clone();\n\n    thread::spawn(move || {\n        tx.send(String::from("hi from raw tx")).unwrap();\n    });\n\n    thread::spawn(move || {\n        tx1.send(String::from("hi from cloned tx")).unwrap();\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Multiple type message:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc::{self, Receiver, Sender};\n\nenum Fruit {\n    Apple(u8),\n    Orange(String)\n}\n\nfn main() {\n    let (tx, rx): (Sender<Fruit>, Receiver<Fruit>) = mpsc::channel();\n\n    tx.send(Fruit::Orange("sweet".to_string())).unwrap();\n    tx.send(Fruit::Apple(2)).unwrap();\n\n    for _ in 0..2 {\n        match rx.recv().unwrap() {\n            Fruit::Apple(count) => println!("received {} apples", count),\n            Fruit::Orange(flavor) => println!("received {} oranges", flavor),\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"tokio-semaphore",children:"Tokio Semaphore"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::sync::Arc;\nuse tokio::sync::Semaphore;\n\n#[tokio::main]\nasync fn main() {\n    let semaphore = Arc::new(Semaphore::new(3));\n    let mut join_handles = Vec::new();\n\n    for _ in 0..5 {\n        let permit = semaphore.clone().acquire_owned().await.unwrap();\n        join_handles.push(tokio::spawn(async move {\n            /**\n             * Task here ...\n             */\n            drop(permit);\n        }));\n    }\n\n    for handle in join_handles {\n        handle.await.unwrap();\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"atomic-primitives",children:"Atomic Primitives"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::ops::Sub;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::thread::{self, JoinHandle};\nuse std::time::Instant;\n\nconst N_TIMES: u64 = 10000000;\nconst N_THREADS: usize = 10;\n\nstatic R: AtomicU64 = AtomicU64::new(0);\n\nfn add_n_times(n: u64) -> JoinHandle<()> {\n    thread::spawn(move || {\n        for _ in 0..n {\n            R.fetch_add(1, Ordering::Relaxed);\n        }\n    })\n}\n\nfn main() {\n    let s = Instant::now();\n    let mut threads = Vec::with_capacity(N_THREADS);\n\n    for _ in 0..N_THREADS {\n        threads.push(add_n_times(N_TIMES));\n    }\n\n    for thread in threads {\n        thread.join().unwrap();\n    }\n\n    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));\n\n    println!("{:?}",Instant::now().sub(s));\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Ordering"})," \u5185\u5b58\u987a\u5e8f:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Relaxed: \u4e71\u5e8f."}),"\n",(0,t.jsx)(e.li,{children:"Release: \u8bbe\u7f6e\u5185\u5b58\u5c4f\u969c, \u4fdd\u8bc1\u5b83\u4e4b\u524d\u7684\u64cd\u4f5c\u6c38\u8fdc\u5728\u5b83\u4e4b\u524d."}),"\n",(0,t.jsx)(e.li,{children:"Acquire: \u8bbe\u7f6e\u5185\u5b58\u5c4f\u969c, \u4fdd\u8bc1\u5b83\u4e4b\u540e\u7684\u64cd\u4f5c\u6c38\u8fdc\u5728\u5b83\u4e4b\u540e."}),"\n",(0,t.jsx)(e.li,{children:"AcqRel: Acquire + Release."}),"\n",(0,t.jsx)(e.li,{children:"SeqCst: \u987a\u5e8f\u4e00\u81f4\u6027."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::thread::{self, JoinHandle};\nuse std::sync::atomic::{Ordering, AtomicBool};\n\nstatic mut DATA: u64 = 0;\nstatic READY: AtomicBool = AtomicBool::new(false);\n\nfn reset() {\n    unsafe {\n        DATA = 0;\n    }\n    READY.store(false, Ordering::Relaxed);\n}\n\nfn producer() -> JoinHandle<()> {\n    thread::spawn(move || {\n        unsafe {\n            DATA = 100;                                 // A\n        }\n        READY.store(true, Ordering::Release);           // B: \u5185\u5b58\u5c4f\u969c \u2191\n    })\n}\n\nfn consumer() -> JoinHandle<()> {\n    thread::spawn(move || {\n        while !READY.load(Ordering::Acquire) {}         // C: \u5185\u5b58\u5c4f\u969c \u2193\n\n        assert_eq!(100, unsafe { DATA });               // D\n    })\n}\n\nfn main() {\n    loop {\n        reset();\n\n        let t_producer = producer();\n        let t_consumer = consumer();\n\n        t_producer.join().unwrap();\n        t_consumer.join().unwrap();\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"Spinlock:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{hint, thread};\n\nfn main() {\n    let spinlock = Arc::new(AtomicUsize::new(1));\n    let spinlock_clone = Arc::clone(&spinlock);\n    let thread = thread::spawn(move|| {\n        spinlock_clone.store(0, Ordering::SeqCst);\n    });\n\n    // \u7b49\u5f85\u5176\u5b83\u7ebf\u7a0b\u91ca\u653e\u9501.\n    while spinlock.load(Ordering::SeqCst) != 0 {\n        hint::spin_loop();\n    }\n\n    if let Err(panic) = thread.join() {\n        println!("Thread had an error: {:?}", panic);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"send-and-sync-trait",children:"Send and Sync Trait"}),"\n",(0,t.jsx)(e.p,{children:"Send and Sync:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Marker trait."}),"\n",(0,t.jsxs)(e.li,{children:["\u5b9e\u73b0 ",(0,t.jsx)(e.code,{children:"Send"})," \u7684\u7c7b\u578b\u53ef\u4ee5\u5728\u7ebf\u7a0b\u95f4\u5b89\u5168\u7684\u4f20\u9012\u5176\u6240\u6709\u6743,\n\u5b9e\u73b0 ",(0,t.jsx)(e.code,{children:"Sync"})," \u7684\u7c7b\u578b\u53ef\u4ee5\u5728\u7ebf\u7a0b\u95f4\u5b89\u5168\u7684\u5171\u4eab (\u901a\u8fc7\u5f15\u7528).\n\u82e5 ",(0,t.jsx)(e.code,{children:"&T: Send"}),", \u5219 ",(0,t.jsx)(e.code,{children:"T: Sync"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["\u7edd\u5927\u90e8\u5206\u7c7b\u578b\u90fd\u5b9e\u73b0\u4e86 ",(0,t.jsx)(e.code,{children:"Send"}),"/",(0,t.jsx)(e.code,{children:"Sync"}),",\n\u4f8b\u5916: \u539f\u751f\u6307\u9488, ",(0,t.jsx)(e.code,{children:"Cell"}),"/",(0,t.jsx)(e.code,{children:"RefCell"}),", ",(0,t.jsx)(e.code,{children:"Rc"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"thread-pool",children:"Thread Pool"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::thread;\n\ntype Job = Box<dyn FnOnce() + Send + \'static>;\n\nenum Message {\n    NewJob(Job),\n    Terminate,\n}\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Message>,\n}\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n        let receiver = Arc::new(Mutex::new(receiver));\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + \'static,\n    {\n        let job = Box::new(f);\n        self.sender.send(Message::NewJob(job)).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        println!("Sending terminate message to all workers.");\n\n        for _ in &self.workers {\n            self.sender.send(Message::Terminate).unwrap();\n        }\n\n        println!("Shutting down all workers.");\n\n        for worker in &mut self.workers {\n            println!("Shutting down worker {}", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv().unwrap();\n\n            match message {\n                Message::NewJob(job) => {\n                    println!("Worker {} got a job; executing.", id);\n                    job();\n                }\n                Message::Terminate => {\n                    println!("Worker {} was told to terminate.", id);\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"asynchronous-programming",children:"Asynchronous Programming"}),"\n",(0,t.jsx)(e.h3,{id:"async-and-await",children:"Async and Await"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u5728 ",(0,t.jsx)(e.code,{children:".await"})," \u6267\u884c\u671f\u95f4, \u4efb\u52a1\u53ef\u80fd\u4f1a\u5728\u7ebf\u7a0b\u95f4\u8f6c\u79fb."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:".await"})," \u53ea\u80fd\u7528\u4e8e async fn \u51fd\u6570\u4e2d."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use futures::executor::block_on;\nuse futures::join;\n\nasync fn learn_song() -> Song { /* ... */ }\nasync fn sing_song(song: Song) { /* ... */ }\nasync fn dance() { /* ... */ }\n\nasync fn learn_and_sing() {\n    let song = learn_song().await;\n    sing_song(song).await;\n}\n\nasync fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n    join!(f1, f2);\n}\n\nfn main() {\n    block_on(async_main());\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use futures::future;\nuse futures::select;\n\npub fn main() {\n    let mut a_fut = future::ready(4);\n    let mut b_fut = future::ready(6);\n    let mut total = 0;\n\n    loop {\n        select! {\n            a = a_fut => total += a,\n            b = b_fut => total += b,\n            complete => break,\n            default => panic!(), // \u8be5\u5206\u652f\u6c38\u8fdc\u4e0d\u4f1a\u8fd0\u884c.\n        };\n    }\n\n    assert_eq!(total, 10);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"future-trait",children:"Future Trait"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Future"})," \u4ee3\u8868\u4e00\u7ec4\u8ba1\u7b97, \u60f0\u6027\u6c42\u503c. \u5f53 ",(0,t.jsx)(e.code,{children:".await"})," \u8c03\u7528\u65f6\u624d\u771f\u6b63\u5f00\u59cb\u6267\u884c."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Future"})," \u542f\u52a8\u540e\u4f1a\u56e0\u8d44\u6e90\u7b49\u539f\u56e0\u963b\u585e, \u8f6c\u5165 ",(0,t.jsx)(e.code,{children:"pending"})," \u72b6\u6001."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Future"})," \u963b\u585e\u540e, \u5f53\u8d44\u6e90\u51c6\u5907\u597d\u53ef\u4ee5\u91cd\u65b0\u542f\u52a8\u65f6, \u4f1a\u901a\u8fc7 ",(0,t.jsx)(e.code,{children:"Waker.wake"})," \u901a\u77e5\u6267\u884c\u5668, \u7b49\u5f85\u88ab\u4e0b\u4e00\u6b21 ",(0,t.jsx)(e.code,{children:"poll"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait Future {\n    type Output;\n    fn poll(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Self::Output>;\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"\nuse std::{\n    future::Future,\n    pin::Pin,\n    sync::{Arc, Mutex},\n    task::{Context, Poll, Waker},\n    thread,\n    time::Duration,\n};\n\npub struct TimerFuture {\n    shared_state: Arc<Mutex<SharedState>>,\n}\n\nstruct SharedState {\n    completed: bool,\n    waker: Option<Waker>,\n}\n\nimpl Future for TimerFuture {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let mut shared_state = self.shared_state.lock().unwrap();\n\n        if shared_state.completed {\n            Poll::Ready(())\n        } else {\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\n\nimpl TimerFuture {\n    pub fn new(duration: Duration) -> Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            waker: None,\n        }));\n\n        let thread_shared_state = shared_state.clone();\n\n        thread::spawn(move || {\n            thread::sleep(duration);\n            let mut shared_state = thread_shared_state.lock().unwrap();\n            shared_state.completed = true;\n            if let Some(waker) = shared_state.waker.take() {\n                waker.wake()\n            }\n        });\n\n        TimerFuture { shared_state }\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["\u5f53 ",(0,t.jsx)(e.code,{children:"Future"})," \u4f1a\u8fd4\u56de ",(0,t.jsx)(e.code,{children:"Poll::Pending"})," \u65f6,\n\u4e00\u5b9a\u8981\u786e\u4fdd ",(0,t.jsx)(e.code,{children:"wake"})," \u80fd\u88ab\u6b63\u5e38\u8c03\u7528,\n\u5426\u5219\u4f1a\u5bfc\u81f4\u4efb\u52a1\u6c38\u8fdc\u88ab\u6302\u8d77,\n\u518d\u4e5f\u4e0d\u4f1a\u88ab\u6267\u884c\u5668 ",(0,t.jsx)(e.code,{children:"poll"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\nuse std::time::{Duration, Instant};\n\nstruct Delay {\n    when: Instant,\n}\n\nimpl Future for Delay {\n    type Output = &\'static str;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<\'_>)\n        -> Poll<&\'static str>\n    {\n        if Instant::now() >= self.when {\n            println!("Hello world");\n            Poll::Ready("done")\n        } else {\n            let waker = cx.waker().clone();\n            let when = self.when;\n\n            thread::spawn(move || {\n                let now = Instant::now();\n\n                if now < when {\n                    thread::sleep(when - now);\n                }\n\n                waker.wake();\n            });\n\n            Poll::Pending\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let when = Instant::now() + Duration::from_millis(10);\n    let future = Delay { when };\n\n    let out = future.await;\n    assert_eq!(out, "done");\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"asynchronous-runtime",children:"Asynchronous Runtime"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use {\n    futures::{\n        future::{BoxFuture, FutureExt},\n        task::{waker_ref, ArcWake},\n    },\n    std::{\n        future::Future,\n        sync::mpsc::{sync_channel, Receiver, SyncSender},\n        sync::{Arc, Mutex},\n        task::{Context, Poll},\n        time::Duration,\n    },\n    // \u5f15\u5165\u4e4b\u524d\u5b9e\u73b0\u7684\u5b9a\u65f6\u5668\u6a21\u5757\n    timer_future::TimerFuture,\n};\n\nstruct Task {\n    future: Mutex<Option<BoxFuture<\'static, ()>>>,\n    task_sender: SyncSender<Arc<Task>>,\n}\n\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let cloned = arc_self.clone();\n        arc_self\n            .task_sender\n            .send(cloned)\n            .expect("\u4efb\u52a1\u961f\u5217\u5df2\u6ee1");\n    }\n}\n\n#[derive(Clone)]\nstruct Spawner {\n    task_sender: SyncSender<Arc<Task>>,\n}\n\nimpl Spawner {\n    fn spawn(&self, future: impl Future<Output = ()> + \'static + Send) {\n        let future = future.boxed();\n        let task = Arc::new(Task {\n            future: Mutex::new(Some(future)),\n            task_sender: self.task_sender.clone(),\n        });\n        self.task_sender.send(task).expect("\u4efb\u52a1\u961f\u5217\u5df2\u6ee1");\n    }\n}\n\nstruct Executor {\n    ready_queue: Receiver<Arc<Task>>,\n}\n\nimpl Executor {\n    fn run(&self) {\n        while let Ok(task) = self.ready_queue.recv() {\n            let mut future_slot = task.future.lock().unwrap();\n\n            if let Some(mut future) = future_slot.take() {\n                let waker = waker_ref(&task);\n                let context = &mut Context::from_waker(&*waker);\n\n                if future.as_mut().poll(context).is_pending() {\n                    // Future \u672a\u6267\u884c\u5b8c\uff0c, \u5c06\u5b83\u653e\u56de\u4efb\u52a1\u4e2d, \u7b49\u5f85\u4e0b\u6b21\u88ab poll.\n                    *future_slot = Some(future);\n                }\n            }\n        }\n    }\n}\n\nfn new_executor_and_spawner() -> (Executor, Spawner) {\n    const MAX_QUEUED_TASKS: usize = 10_000;\n    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);\n    (Executor { ready_queue }, Spawner { task_sender })\n}\n\nfn main() {\n    let (executor, spawner) = new_executor_and_spawner();\n\n    spawner.spawn(async {\n        println!("howdy!");\n        TimerFuture::new(Duration::new(2, 0)).await;\n        println!("done!");\n    });\n\n    drop(spawner);\n\n    // \u8fd0\u884c\u6267\u884c\u5668\u76f4\u5230\u4efb\u52a1\u961f\u5217\u4e3a\u7a7a.\n    // \u4efb\u52a1\u8fd0\u884c\u540e, \u4f1a\u5148\u6253\u5370 `howdy!`, \u6682\u505c 2 \u79d2, \u63a5\u7740\u6253\u5370 `done!`.\n    executor.run();\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::cell::RefCell;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::sync::{Arc, Mutex};\nuse std::task::{Context, Poll, Waker};\nuse std::thread;\nuse std::time::{Duration, Instant};\nuse futures::task::{self, ArcWake};\nuse crossbeam::channel;\n\nfn main() {\n    let mini_tokio = MiniTokio::new();\n\n    mini_tokio.spawn(async {\n        spawn(async {\n            delay(Duration::from_millis(100)).await;\n            println!(\"world\");\n        });\n\n        spawn(async {\n            println!(\"hello\");\n        });\n\n        delay(Duration::from_millis(200)).await;\n        std::process::exit(0);\n    });\n\n    mini_tokio.run();\n}\n\nstruct MiniTokio {\n    scheduled: channel::Receiver<Arc<Task>>,\n    sender: channel::Sender<Arc<Task>>,\n}\n\nimpl MiniTokio {\n    fn new() -> MiniTokio {\n        let (sender, scheduled) = channel::unbounded();\n\n        MiniTokio { scheduled, sender }\n    }\n\n    fn spawn<F>(&self, future: F)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        Task::spawn(future, &self.sender);\n    }\n\n    fn run(&self) {\n        CURRENT.with(|cell| {\n            *cell.borrow_mut() = Some(self.sender.clone());\n        });\n\n        while let Ok(task) = self.scheduled.recv() {\n            task.poll();\n        }\n    }\n}\n\npub fn spawn<F>(future: F)\nwhere\n    F: Future<Output = ()> + Send + 'static,\n{\n    CURRENT.with(|cell| {\n        let borrow = cell.borrow();\n        let sender = borrow.as_ref().unwrap();\n        Task::spawn(future, sender);\n    });\n}\n\nasync fn delay(dur: Duration) {\n    struct Delay {\n        when: Instant,\n        waker: Option<Arc<Mutex<Waker>>>,\n    }\n\n    impl Future for Delay {\n        type Output = ();\n\n        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n            if let Some(waker) = &self.waker {\n                let mut waker = waker.lock().unwrap();\n\n                if !waker.will_wake(cx.waker()) {\n                    *waker = cx.waker().clone();\n                }\n            } else {\n                let when = self.when;\n                let waker = Arc::new(Mutex::new(cx.waker().clone()));\n                self.waker = Some(waker.clone());\n\n                thread::spawn(move || {\n                    let now = Instant::now();\n\n                    if now < when {\n                        thread::sleep(when - now);\n                    }\n\n                    let waker = waker.lock().unwrap();\n                    waker.wake_by_ref();\n                });\n            }\n\n            if Instant::now() >= self.when {\n                Poll::Ready(())\n            } else {\n                Poll::Pending\n            }\n        }\n    }\n\n    let future = Delay {\n        when: Instant::now() + dur,\n        waker: None,\n    };\n\n    future.await;\n}\n\nthread_local! {\n    static CURRENT: RefCell<Option<channel::Sender<Arc<Task>>>> =\n        RefCell::new(None);\n}\n\nstruct Task {\n    future: Mutex<Pin<Box<dyn Future<Output = ()> + Send>>>,\n    executor: channel::Sender<Arc<Task>>,\n}\n\nimpl Task {\n    fn spawn<F>(future: F, sender: &channel::Sender<Arc<Task>>)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        let task = Arc::new(Task {\n            future: Mutex::new(Box::pin(future)),\n            executor: sender.clone(),\n        });\n\n        let _ = sender.send(task);\n    }\n\n    fn poll(self: Arc<Self>) {\n        let waker = task::waker(self.clone());\n        let mut cx = Context::from_waker(&waker);\n        let mut future = self.future.try_lock().unwrap();\n        let _ = future.as_mut().poll(&mut cx);\n    }\n}\n\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let _ = arc_self.executor.send(arc_self.clone());\n    }\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[tokio::main]\nasync fn main() {\n    println!("Hello world");\n}\n\nfn main() {\n    tokio::runtime::Builder::new_multi_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            println!("Hello world");\n        })\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"io",children:"IO"}),"\n",(0,t.jsx)(e.h3,{id:"path",children:"Path"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::path::Path;\n\nfn main() {\n    let path = Path::new(".");\n    let new_path = path.join("a").join("b");\n\n    // \u5c06\u8def\u5f84\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u5207\u7247\n    match new_path.to_str() {\n        None => panic!("new path is not a valid UTF-8 sequence"),\n        Some(s) => println!("new path is {}", s),\n    }\n\n    // `display` \u65b9\u6cd5\u8fd4\u56de\u4e00\u4e2a\u53ef\u663e\u793a\u7684\u7ed3\u6784\u4f53\n    let display = path.display();\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"files",children:"Files"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"File::open"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"File::create"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"file.read_to_string"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"file.write_all"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"bufReader.lines"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"OpenOptions"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fs::read_dir"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fs::create_dir"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fs::create_dir_all"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fs::remove_file"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fs::remove_dir"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"fs::symlink"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new("hello.txt");\n    let display = path.display();\n\n    let mut file = match File::open(&path) {\n        Err(why) => panic!("couldn\'t open {}: {}", display,\n                                                   why.description()),\n        Ok(file) => file,\n    };\n\n    let mut s = String::new();\n    match file.read_to_string(&mut s) {\n        Err(why) => panic!("couldn\'t read {}: {}", display,\n                                                   why.description()),\n        Ok(_) => print!("{} contains:\\n{}", display, s),\n    }\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nfn main() {\n    if let Ok(lines) = read_lines("./hosts") {\n        for line in lines {\n            if let Ok(ip) = line {\n                println!("{}", ip);\n            }\n        }\n    }\n}\n\nfn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>\nwhere P: AsRef<Path>, {\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'static LOREM_IPSUM: &\'static str = "Words";\n\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new("out/lorem_ipsum.txt");\n    let display = path.display();\n\n    let mut file = match File::create(&path) {\n        Err(why) => panic!("couldn\'t create {}: {}",\n                           display,\n                           why.description()),\n        Ok(file) => file,\n    };\n\n    match file.write_all(LOREM_IPSUM.as_bytes()) {\n        Err(why) => {\n            panic!("couldn\'t write to {}: {}", display,\n                                               why.description())\n        },\n        Ok(_) => println!("successfully wrote to {}", display),\n    }\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io;\nuse std::io::prelude::*;\nuse std::os::unix;\nuse std::path::Path;\n\nfn cat(path: &Path) -> io::Result<String> {\n    let mut f = File::open(path)?;\n    let mut s = String::new();\n    match f.read_to_string(&mut s) {\n        Ok(_) => Ok(s),\n        Err(e) => Err(e),\n    }\n}\n\nfn echo(s: &str, path: &Path) -> io::Result<()> {\n    let mut f = File::create(path)?;\n    f.write_all(s.as_bytes())\n}\n\nfn touch(path: &Path) -> io::Result<()> {\n    match OpenOptions::new().create(true).write(true).open(path) {\n        Ok(_) => Ok(()),\n        Err(e) => Err(e),\n    }\n}\n\nfn main() {\n    println!("`mkdir a`");\n    match fs::create_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(_) => {},\n    }\n\n    println!("`echo hello > a/b.txt`");\n    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`mkdir -p a/c/d`");\n    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`touch a/c/e.txt`");\n    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`ln -s ../b.txt a/c/b.txt`");\n    if cfg!(target_family = "unix") {\n        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n        });\n    }\n\n    println!("`cat a/c/b.txt`");\n    match cat(&Path::new("a/c/b.txt")) {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(s) => println!("> {}", s),\n    }\n\n    println!("`ls a`");\n    match fs::read_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(paths) => for path in paths {\n            println!("> {:?}", path.unwrap().path());\n        },\n    }\n\n    println!("`rm a/c/e.txt`");\n    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`rmdir a/c/d`");\n    fs::remove_dir("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"system",children:"System"}),"\n",(0,t.jsx)(e.h3,{id:"process",children:"Process"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::process::Command;\n\nfn main() {\n    let output = Command::new("rustc")\n        .arg("--version")\n        .output().unwrap_or_else(|e| {\n            panic!("failed to execute process: {}", e)\n    });\n\n    if output.status.success() {\n        let s = String::from_utf8_lossy(&output.stdout);\n        print!("rustc succeeded and stdout was:\\n{}", s);\n    } else {\n        let s = String::from_utf8_lossy(&output.stderr);\n        print!("rustc failed and stderr was:\\n{}", s);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::error::Error;\nuse std::io::prelude::*;\nuse std::process::{Command, Stdio};\n\nstatic PROGRAM: &\'static str =\n"the quick brown fox jumped over the lazy dog\\n";\n\nfn main() {\n    let process = match Command::new("wc")\n                                .stdin(Stdio::piped())\n                                .stdout(Stdio::piped())\n                                .spawn() {\n        Err(why) => panic!("couldn\'t spawn wc: {}", why.description()),\n        Ok(process) => process,\n    };\n\n    match process.stdin.unwrap().write_all(PROGRAM.as_bytes()) {\n        Err(why) => panic!("couldn\'t write to wc stdin: {}",\n                           why.description()),\n        Ok(_) => println!("sent program to wc"),\n    }\n\n    let mut s = String::new();\n    match process.stdout.unwrap().read_to_string(&mut s) {\n        Err(why) => panic!("couldn\'t read wc stdout: {}",\n                           why.description()),\n        Ok(_) => print!("wc responded with:\\n{}", s),\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"command-line",children:"Command Line"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'\nuse std::env;\nuse std::error::Error;\nuse std::fs;\nuse std::process;\n\npub struct Config {\n    pub query: String,\n    pub filename: String,\n    pub case_sensitive: bool,\n}\n\nimpl Config {\n    pub fn new(args: &[String]) -> Result<Config, &\'static str> {\n        if args.len() < 3 {\n            return Err("not enough arguments");\n        }\n\n        let query = args[1].clone();\n        let filename = args[2].clone();\n\n        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();\n\n        Ok(Config {\n            query,\n            filename,\n            case_sensitive,\n        })\n    }\n}\n\npub fn run(config: Config) -> Result<(), Box<dyn Error>> {\n    let contents = fs::read_to_string(config.filename)?;\n\n    let results = if config.case_sensitive {\n        search(&config.query, &contents)\n    } else {\n        search_case_insensitive(&config.query, &contents)\n    };\n\n    for line in results {\n        println!("{}", line);\n    }\n\n    Ok(())\n}\n\npub fn search<\'a>(query: &str, contents: &\'a str) -> Vec<&\'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\npub fn search_case_insensitive<\'a>(\n    query: &str,\n    contents: &\'a str,\n) -> Vec<&\'a str> {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let config = Config::new(&args).unwrap_or_else(|err| {\n        eprintln!("Problem parsing arguments: {}", err);\n        process::exit(1);\n    });\n\n    if let Err(e) = run(config) {\n        eprintln!("Application error: {}", e);\n\n        process::exit(1);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"tests",children:"Tests"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn greeting(name: &str) -> String {\n    format!("Hello {}!", name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[ignore]\n    #[should_panic]\n    #[should_panic(expected = "Panic message.")]\n    fn greeting_contains_name() {\n        let target = "name";\n        let result = greeting("Name");\n        assert!(\n            result.contains(target),\n            "Expect: `{}`, Result: `{}`",\n            target,\n            result\n        );\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"macros",children:"Macros"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"unsafe-code",children:"Unsafe Code"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"unsafe {}"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u5bf9\u539f\u59cb\u6307\u9488\u8fdb\u884c\u89e3\u5f15\u7528."}),"\n",(0,t.jsxs)(e.li,{children:["\u8c03\u7528",(0,t.jsx)(e.code,{children:"\u4e0d\u5b89\u5168"}),"\u7684\u51fd\u6570 (\u5305\u62ec C \u51fd\u6570, \u7f16\u8bd1\u5668\u5185\u5efa\u6307\u4ee4, \u539f\u59cb\u5206\u914d\u5668)."]}),"\n",(0,t.jsxs)(e.li,{children:["\u5b9e\u73b0",(0,t.jsx)(e.code,{children:"\u4e0d\u5b89\u5168"}),"\u7684\u7279\u6027."]}),"\n",(0,t.jsxs)(e.li,{children:["\u8bbf\u95ee",(0,t.jsx)(e.code,{children:"union"}),"\u5b57\u6bb5."]}),"\n",(0,t.jsx)(e.li,{children:"\u6539\u53d8\u9759\u6001\u6570\u636e."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"comments",children:"Comments"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Line Comments\n/* Block Comments */\n/// Document Line Comments\n/** Document Block Comments */\n//! Crate Line Comments\n/*! Crate Block Comments */\n\n/// [`Option`]\n/// [`Type`](struct@Type)\n/// [`Type`](fn@Type)\n\n#[doc(alias = "alias" )]\n'})}),"\n",(0,t.jsx)(e.h2,{id:"attributes",children:"Attributes"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Crate scope:",(0,t.jsx)(e.code,{children:"#![crate_attribute]"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Module/Function scope: ",(0,t.jsx)(e.code,{children:"#[item_attribute]"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[attribute = "value"]\n#[attribute(key = "value")]\n#[attribute(value)]\n'})}),"\n",(0,t.jsx)(e.h3,{id:"crate-attributes",children:"Crate Attributes"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#![crate_type = "lib"]\n#![crate_name = "rand"]\n'})}),"\n",(0,t.jsx)(e.h3,{id:"linter-attributes",children:"Linter Attributes"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"#[allow(dead_code)]\n#[allow(unused)]\n"})}),"\n",(0,t.jsx)(e.h3,{id:"compile-attributes",children:"Compile Attributes"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[cfg(target_os = "linux")]\nfn are_you_on_linux() {\n    println!("You are running linux!")\n}\n\n#[cfg(not(target_os = "linux"))]\nfn are_you_on_linux() {\n    println!("You are *not* running linux!")\n}\n\nfn main() {\n    are_you_on_linux();\n\n    if cfg!(target_os = "linux") {\n        println!("Yes. It\'s definitely linux!");\n    } else {\n        println!("Yes. It\'s definitely *not* linux!");\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"standard-library",children:"Standard Library"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"as_"}),": ",(0,t.jsx)(e.code,{children:"borrowed"})," -> ",(0,t.jsx)(e.code,{children:"borrowed"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"into_"}),": ",(0,t.jsx)(e.code,{children:"owned"})," -> ",(0,t.jsx)(e.code,{children:"owned"})," (\u79fb\u9664\u6240\u6709\u6743)."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"to_"}),":\n",(0,t.jsx)(e.code,{children:"borrowed"})," -> ",(0,t.jsx)(e.code,{children:"borrowed"}),",\n",(0,t.jsx)(e.code,{children:"borrowed"})," -> ",(0,t.jsx)(e.code,{children:"owned"})," on non-copy types,\n",(0,t.jsx)(e.code,{children:"owned"})," -> ",(0,t.jsx)(e.code,{children:"owned"})," on copy types."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"try_"}),": \u5c1d\u8bd5\u4e00\u6b21, \u5931\u8d25\u5219\u8fd4\u56de\u6216\u62a5\u9519."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"_mut"}),": \u53ef\u53d8\u501f\u7528."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"web-development",children:"Web Development"}),"\n",(0,t.jsx)(e.h3,{id:"nodejs-bindings",children:"Node.js Bindings"}),"\n",(0,t.jsxs)(e.p,{children:["Tasks suite for native ",(0,t.jsx)(e.code,{children:"Node.js"})," add-ons:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Computing intensive tasks with simple I/O:\ne.g ",(0,t.jsx)(e.code,{children:"@node-rs/crc32"})," (CPU SIMD instruction), ",(0,t.jsx)(e.code,{children:"@node-rs/bcrypt"}),", ",(0,t.jsx)(e.code,{children:"@node-rs/jieba"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"System call tasks:\nSIMD instruction, GPU instruction."}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://github.com/napi-rs/napi-rs",children:"Napi"}),":\nFramework for building compiled ",(0,t.jsx)(e.code,{children:"Node.js"})," add-ons in ",(0,t.jsx)(e.code,{children:"Rust"})," via Node API."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[macro_use]\nextern crate napi;\n\n/// import the preludes\nuse napi::bindgen_prelude::*;\n\n/// module registration is done by the runtime, no need to explicitly do it now.\n#[napi]\nfn fibonacci(n: u32) -> u32 {\n    match n {\n        1 | 2 => 1,\n        _ => fibonacci(n - 1) + fibonacci(n - 2),\n    }\n}\n\n/// use `Fn`, `FnMut` or `FnOnce` traits to defined JavaScript callbacks\n/// the return type of callbacks can only be `Result`.\n#[napi]\nfn get_cwd<T: Fn(String) -> Result<()>>(callback: T) {\n    callback(env::current_dir().unwrap().to_string_lossy().to_string()).unwrap();\n}\n\n/// or, define the callback signature in where clause\n#[napi]\nfn test_callback<T>(callback: T)\nwhere T: Fn(String) -> Result<()>\n{}\n\n/// async fn, require `async` feature enabled.\n/// [dependencies]\n/// napi = {version="2", features=["async"]}\n#[napi]\nasync fn read_file_async(path: String) -> Result<Buffer> {\n    tokio::fs::read(path)\n        .map(|r| match r {\n            Ok(content) => Ok(content.into()),\n            Err(e) => Err(Error::new(\n                Status::GenericFailure,\n                format!("failed to read file, {}", e),\n            )),\n        })\n        .await\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://github.com/neon-bindings/neon",children:"Neon"}),":\n",(0,t.jsx)(e.code,{children:"Rust"})," bindings for safe and fast native ",(0,t.jsx)(e.code,{children:"Node.js"})," modules."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use neon::context::{Context, ModuleContext, FunctionContext};\nuse neon::types::JsNumber;\nuse neon::result::JsResult;\nuse neon::result::NeonResult;\n\nfn fibonacci(n: i32) -> i32 {\n    return match n {\n        n if n < 1 => 0,\n        n if n <= 2 => 1,\n        _ => fibonacci(n - 1) + fibonacci(n - 2)\n  }\n}\n\nfn fibonacci_api(mut cx: FunctionContext) -> JsResult<JsNumber> {\n    let handle = cx.argument::<JsNumber>(0).unwrap();\n    let res = fibonacci(handle.value(&mut cx) as i32);\n    Ok(cx.number(res))\n}\n\n#[neon::main]\nfn main(mut cx: ModuleContext) -> NeonResult<()> {\n    cx.export_function("fibonacci_rs", fibonacci_api)?;\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"const { fibonacci_rs } = require('./index.node')\n\nconst value = process.argv[2] || null\nconst number = Number.parseInt(value)\n\nif (Number.isNaN(number)) {\n  console.log('Provided value is not a number')\n  return\n}\n\nconst result = fibonacci_rs(number)\nconsole.log(result)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"library",children:"Library"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-num/num",children:"Num: Numeric Types and Traits"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-random/rand",children:"Rand: Random Number Generator"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/regex",children:"Regex: Regular Expression Engine"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rulex-rs/rulex",children:"RuleX: A New and Portable Regular Expression Language"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/chronotope/chrono",children:"Chrono: DateTime Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/async-rs/async-std",children:"AsyncStd: Asynchronous Version Standard Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/crossbeam-rs/crossbeam",children:"Crossbeam: Concurrent Programming Tools"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/tokio-rs/tokio",children:"Tokio: Asynchronous Runtime"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rayon-rs/rayon",children:"Rayon: Data Parallelism Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/log",children:"Log: Logging Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/tokio-rs/tracing",children:"Tracing: Tracing Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/serde-rs/serde",children:"Serde: Serialization Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/tokio-rs/axum",children:"Axum: Tokio Web Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/SergioBenitez/Rocket",children:"Rocket: Web Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/actix/actix-web",children:"Actix: Web Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/seanmonstar/warp",children:"Warp: Web Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/seanmonstar/reqwest",children:"Request: HTTP Client"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/cloudflare/quiche",children:"Quiche: QUIC and HTTP/3 Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/hyperium/tonic",children:"Tonic: gPRC Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/quickwit-oss/quickwit",children:"QuickWit: Distributed Search Engine"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/meilisearch/MeiliSearch",children:"MeiliSearch: Realtime Search Engine"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/clap-rs/clap",children:"Clap: CLI Framework"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/console-rs/indicatif",children:"Console: ProgressBar"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/dtolnay/syn",children:"Syn: Source Code Parser"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"https://github.com/napi-rs/napi-rs",children:"Napi: Node.js Bindings Library"}),":"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"https://github.com/neon-bindings/neon",children:"Neon: Node.js Bindings Library"}),":"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/git2-rs",children:"Git: Git Bindings Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/colin-kiegel/rust-pretty-assertions",children:"PrettyAssertions"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/bheisler/criterion.rs",children:"Criterion: Benchmarking Library"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/clog-tool/clog-cli",children:"Clog: Conventional Changelog"})}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/book",children:"Rust Book"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/nomicon",children:"Rust Nomicon"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/async-book",children:"Rust Asynchronism"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-unofficial/too-many-lists",children:"Rust Data Structures"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/rust-by-example",children:"Rust Example"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/rust-lang/rustlings",children:"Rust Lings"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/sunface/rust-course",children:"Rust Course"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},842:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>a});var s=r(8101);const t={},l=s.createContext(t);function i(n){const e=s.useContext(l);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:i(n.components),s.createElement(l.Provider,{value:e},n.children)}}}]);