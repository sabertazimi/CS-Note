"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[7368],{4927:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"Programming/FunctionalProgramming/FunctionalProgrammingBasicNotes","title":"Functional Programming Basic Notes","description":"Lambda Calculus","source":"@site/notes/Programming/FunctionalProgramming/FunctionalProgrammingBasicNotes.md","sourceDirName":"Programming/FunctionalProgramming","slug":"/Programming/FunctionalProgramming/FunctionalProgrammingBasicNotes","permalink":"/awesome-notes/Programming/FunctionalProgramming/FunctionalProgrammingBasicNotes","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/awesome-notes/edit/main/notes/Programming/FunctionalProgramming/FunctionalProgrammingBasicNotes.md","tags":[{"inline":true,"label":"Programming","permalink":"/awesome-notes/tags/programming"},{"inline":true,"label":"Functional Programming","permalink":"/awesome-notes/tags/functional-programming"}],"version":"current","lastUpdatedBy":"sabertazimi","lastUpdatedAt":1712724461000,"frontMatter":{"author":"Sabertazimi","authorTitle":"Web Developer","authorURL":"https://github.com/sabertazimi","authorImageURL":"https://github.com/sabertazimi.png","tags":["Programming","Functional Programming"]},"sidebar":"tutorialSidebar","previous":{"title":"Docker Basic Notes","permalink":"/awesome-notes/Programming/DevOps/DockerBasicNotes"},"next":{"title":"Game Design Basic Notes","permalink":"/awesome-notes/Programming/Gaming/GameDesignBasicNotes"}}');var a=i(5105),s=i(842);const r={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Programming","Functional Programming"]},t="Functional Programming Basic Notes",o={},c=[{value:"Lambda Calculus",id:"lambda-calculus",level:2},{value:"Lambda Expression (Lambda-Term)",id:"lambda-expression-lambda-term",level:3},{value:"Lambda Reduction",id:"lambda-reduction",level:3},{value:"\u03b1 \u8f6c\u6362",id:"\u03b1-\u8f6c\u6362",level:4},{value:"\u03b2 \u5f52\u7ea6",id:"\u03b2-\u5f52\u7ea6",level:4},{value:"\u03b7 \u5f52\u7ea6",id:"\u03b7-\u5f52\u7ea6",level:4},{value:"Church Numerals",id:"church-numerals",level:3},{value:"Definition for Functional Programming",id:"definition-for-functional-programming",level:2},{value:"Datatype",id:"datatype",level:2},{value:"Datatype Binding",id:"datatype-binding",level:3},{value:"Built-in Tagged Constructor",id:"built-in-tagged-constructor",level:3},{value:"Type Constructor",id:"type-constructor",level:3},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Tail Position, Tail expression, Tail Call and Tail Recursion",id:"tail-position-tail-expression-tail-call-and-tail-recursion",level:2},{value:"Rules for expressions",id:"rules-for-expressions",level:2},{value:"samples",id:"samples",level:3},{value:"Standard ML",id:"standard-ml",level:2},{value:"functions",id:"functions",level:3},{value:"tuples",id:"tuples",level:3},{value:"lists",id:"lists",level:3},{value:"let expressions",id:"let-expressions",level:3},{value:"options",id:"options",level:3},{value:"boolean operations",id:"boolean-operations",level:3},{value:"closure",id:"closure",level:3},{value:"lexical scope vs dynamic scope",id:"lexical-scope-vs-dynamic-scope",level:4},{value:"compose and pipeline",id:"compose-and-pipeline",level:4},{value:"curry and unCurry",id:"curry-and-uncurry",level:4},{value:"Type inference",id:"type-inference",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"functional-programming-basic-notes",children:"Functional Programming Basic Notes"})}),"\n",(0,a.jsx)(n.h2,{id:"lambda-calculus",children:"Lambda Calculus"}),"\n",(0,a.jsx)(n.h3,{id:"lambda-expression-lambda-term",children:"Lambda Expression (Lambda-Term)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Variable: x"}),"\n",(0,a.jsx)(n.li,{children:"Abstraction: \u03bbx.M"}),"\n",(0,a.jsx)(n.li,{children:"Application: M N"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"e.g. \u03bbx.y \u03bbx.(\u03bby.xy)"}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u53d8\u91cf x \u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u6709\u6548\u7684 lambda \u9879"}),"\n",(0,a.jsx)(n.li,{children:"\u5982\u679c t \u662f\u4e00\u4e2a lambda \u9879\uff0c\u800c x \u662f\u4e00\u4e2a\u53d8\u91cf\uff0c\u5219 \u03bbx.t \u662f\u4e00\u4e2a lambda \u9879\uff08\u79f0\u4e3a lambda \u62bd\u8c61\uff09"}),"\n",(0,a.jsx)(n.li,{children:"\u5982\u679c t \u548c s \u662f lambda \u9879\uff0c\u90a3\u4e48 (ts) \u662f\u4e00\u4e2a lambda \u9879\uff08\u79f0\u4e3a\u5e94\u7528\uff09"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"lambda-reduction",children:"Lambda Reduction"}),"\n",(0,a.jsx)(n.h4,{id:"\u03b1-\u8f6c\u6362",children:"\u03b1 \u8f6c\u6362"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"\u03b1: \u03bbx.x \u2261 \u03bby.y"})," \u7b49\u4ef7\u53d8\u91cf\u66ff\u6362"]}),"\n",(0,a.jsx)(n.h4,{id:"\u03b2-\u5f52\u7ea6",children:"\u03b2 \u5f52\u7ea6"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"\u03b2: ((\u03bbV.E) E\u2032) \u2261 E[V := E\u2032]"})," \u51fd\u6570\u62bd\u8c61\u5e94\u7528(apply)\u4e8e\u53c2\u6570\u7684\u8fc7\u7a0b"]}),"\n",(0,a.jsx)(n.h4,{id:"\u03b7-\u5f52\u7ea6",children:"\u03b7 \u5f52\u7ea6"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"\u03bbx.M x \u2261 M"})," \u7528\u4e8e\u6e05\u9664 lambda \u8868\u8fbe\u5f0f\u4e2d\u5b58\u5728\u7684\u5197\u4f59\u51fd\u6570\u62bd\u8c61"]}),"\n",(0,a.jsx)(n.h3,{id:"church-numerals",children:"Church Numerals"}),"\n",(0,a.jsxs)(n.p,{children:["\u6309\u7167\u76ae\u4e9a\u8bfa\u516c\u7406\u53ef\u5f97\u81ea\u7136\u6570\u96c6\u5408\u8868\u793a\u4e3a ",(0,a.jsx)(n.code,{children:"{0, S(0), S(S(0)), ...}"}),", \u4e8e\u662f\u5f97\u5230\u5982\u4e0b\u5b9a\u4e49:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"S \u2261 \u03bbn.\u03bbf.\u03bbx.f (n f x)\n\n0 \u2261 \u03bbf.\u03bbx.x\n1 \u2261 \u03bbf.\u03bbx.f x\n2 \u2261 \u03bbf.\u03bbx.f (f x)\n3 \u2261 \u03bbf.\u03bbx.f (f (f x))\n...\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u5bf9\u540e\u7ee7\u51fd\u6570 S \u548c\u4e18\u5947\u6570\u7684\u7b80\u5355\u9a8c\u8bc1\u5982\u4e0b\uff1a"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"S 0\n\u2261 (\u03bbn.\u03bbf.\u03bbx.f (n f x)) \u03bbf.\u03bbx.x\n= (\u03bbn.\u03bbg.\u03bby.g (n g y)) \u03bbf.\u03bbx.x    // alpha\n= (\u03bbf.\u03bbx.f (n f x))[n := \u03bbf.\u03bbx.x] // beta\n= \u03bbg.\u03bby.g ((\u03bbf.\u03bbx.x) g y)         // substitute\n= \u03bbg.\u03bby.g (x[f := g, x := y])     // beta\n= \u03bbg.\u03bby.g y                       // substitute\n= \u03bbf.\u03bbx.f x                       // alpha\n\u2261 1\n"})}),"\n",(0,a.jsx)(n.h2,{id:"definition-for-functional-programming",children:"Definition for Functional Programming"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"avoid mutation"}),"\n",(0,a.jsx)(n.li,{children:"first class functions"}),"\n",(0,a.jsx)(n.li,{children:"recursive data structures and recursive functions"}),"\n",(0,a.jsx)(n.li,{children:"laziness"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"datatype",children:"Datatype"}),"\n",(0,a.jsx)(n.h3,{id:"datatype-binding",children:"Datatype Binding"}),"\n",(0,a.jsx)(n.p,{children:"tagged union, every constructor name as tag,\nfields for different constructors can't exist at the same time"}),"\n",(0,a.jsx)(n.h3,{id:"built-in-tagged-constructor",children:"Built-in Tagged Constructor"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"NONE"}),"\n",(0,a.jsx)(n.li,{children:"SOME i"}),"\n",(0,a.jsx)(n.li,{children:"[]"}),"\n",(0,a.jsx)(n.li,{children:"x :: xs (infix constructor)"}),"\n",(0,a.jsx)(n.li,{children:"()"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"type-constructor",children:"Type Constructor"}),"\n",(0,a.jsx)(n.p,{children:"type constructor: datatype bindings with variables"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"datatype 'a myList = EMPTY | CONS of 'a * 'a myList\nmyList isn't a type, int list is a type\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"'a , 'a equivalent/different"}),"\n",(0,a.jsx)(n.li,{children:"'a, 'b different"}),"\n",(0,a.jsx)(n.li,{children:"''a, ''a equivalent"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"null/isSome check tag part\uff08variant\uff09"}),"\n",(0,a.jsx)(n.li,{children:"hd/tl/valOf check data part (extract data)"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"case e of\n      p1 => e1\n    | pn => en\n\nval p = e (* declare multiple variables once time in p(pattern) *)\n\n(* declare multiple callee arguments(hidden to caller) once time in p(pattern) *)\nfun foo p = e\n"})}),"\n",(0,a.jsx)(n.p,{children:"In SML, all functions only take 1 argument, a tuple/record:"}),"\n",(0,a.jsx)(n.p,{children:"fun f (x, y, z) = x + y + z seems that takes 3 arguments,\nbut truly owing to pattern matching only takes 1 tuple argument\nLikewise, fun f () = 0 takes 1 empty tuple argument."}),"\n",(0,a.jsx)(n.p,{children:"Further more, tuples is syntactic sugar for records."}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"As a whole: all functions only take 1 record argument owing to pattern matching."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"tail-position-tail-expression-tail-call-and-tail-recursion",children:"Tail Position, Tail expression, Tail Call and Tail Recursion"}),"\n",(0,a.jsx)(n.p,{children:"recursive definition for Tail Position:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"if E isn't in tail position, then sub expressions of E aren't in tail position"}),"\n",(0,a.jsx)(n.li,{children:"if E is in tail position, then some sub expressions of E are in tail position"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"if eb then e1 else e2\n"})}),"\n",(0,a.jsx)(n.p,{children:"is in tail position, then e1 and e2 are in tail position, not eb"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"f (x, e)\n"})}),"\n",(0,a.jsx)(n.p,{children:"is in tail position, then f is in tail position(tail call), not x and e"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"fun factorial n =\n    let\n        fun aux(n, acc) =\n            if\n                n = 0\n            then\n                acc\n            else\n                aux (n-1, n*acc)\n    in\n        aux (n,1)\n    end\n"})}),"\n",(0,a.jsx)(n.h2,{id:"rules-for-expressions",children:"Rules for expressions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Syntactic: syntax rules"}),"\n",(0,a.jsx)(n.li,{children:"Semantic: type checking rules"}),"\n",(0,a.jsx)(n.li,{children:"Runtime: evaluation rules"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"samples",children:"samples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"syntax: if e1 then e2 else e3\ntype: e1 = bool,  e2 = e3 = any\nevaluation: e1 ? e2 : e3\n"})}),"\n",(0,a.jsx)(n.h2,{id:"standard-ml",children:"Standard ML"}),"\n",(0,a.jsx)(n.h3,{id:"functions",children:"functions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"syntax: fun name (arg1: type1, .., argN: typeN) = body\ntype: name = type1 * ... * typeN -> body_type\nlazy evaluation\n"})}),"\n",(0,a.jsx)(n.h3,{id:"tuples",children:"tuples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"(* tuples *)\nsyntax: e = (e1, ..., en)\ntype: e1 * ... * en (can become fun's arguments list)\nevaluation: #1 e, #2 e, ..., #n e\n"})}),"\n",(0,a.jsx)(n.h3,{id:"lists",children:"lists"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"(* lists *)\nsyntax: l = [e1, ..., en]\ntype: [] = elem_type list; hd(head) l = elem_type, tl(tail) x = elem_type list\nevaluation: cons = e :: l; null [] = false;\n\n> 6 :: [1, 3, 5]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"let-expressions",children:"let expressions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"syntax: let\n            b1 b2 ... bn\n        in\n            body\n        end\ntype: whole let type = body_type\nevaluation: whole let result = body_result\n"})}),"\n",(0,a.jsx)(n.h3,{id:"options",children:"options"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"NONE : type = 'a option"}),"\n",(0,a.jsxs)(n.li,{children:["SOME e: type = ",(0,a.jsx)(n.code,{children:"e_type"})," option"]}),"\n",(0,a.jsx)(n.li,{children:"isSome: type = 'a option -> bool"}),"\n",(0,a.jsx)(n.li,{children:"valOf : type = 'a option -> 'a"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"boolean-operations",children:"boolean operations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"e1 andalso e2: keyword"}),"\n",(0,a.jsx)(n.li,{children:"e1 orelse e2 : keyword"}),"\n",(0,a.jsx)(n.li,{children:"not e1 : bool -> bool"}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"="}),"(equal) ",(0,a.jsx)(n.code,{children:"<>"}),"(not equal) ",(0,a.jsx)(n.code,{children:">"})," ",(0,a.jsx)(n.code,{children:"<"})," ",(0,a.jsx)(n.code,{children:">="})," ",(0,a.jsx)(n.code,{children:"<="}),": require two same type elem"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"closure",children:"closure"}),"\n",(0,a.jsx)(n.h4,{id:"lexical-scope-vs-dynamic-scope",children:"lexical scope vs dynamic scope"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"lexical scope: function where defined"}),"\n",(0,a.jsx)(n.li,{children:"dynamic scope: function where called"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"compose-and-pipeline",children:"compose and pipeline"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"fun sqrt_of_abs = Math.sqrt o Real.fromInt o abs\n\ninfix !>\nfun x !> f = f x\n\nfun sqrt_of_abs i = i !> abs !> Real.fromInt !> Math.sqrt\n"})}),"\n",(0,a.jsx)(n.h4,{id:"curry-and-uncurry",children:"curry and unCurry"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"fun carry f x y = f (x, y)\nfun unCarry f (x, y) = f x y\n\nfun range (i, j) = if i > j then [] else i :: range(i+1, j)\nfun countUp = curry range 1\n\nval arr = countUp 7 (* maps to [1, 2, ..., 7] *)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"type-inference",children:"Type inference"})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},842:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>t});var l=i(8101);const a={},s=l.createContext(a);function r(e){const n=l.useContext(s);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),l.createElement(s.Provider,{value:n},e.children)}}}]);