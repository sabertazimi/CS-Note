"use strict";(self.webpackChunkawesome_notes=self.webpackChunkawesome_notes||[]).push([[7434],{5490:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Web/React/ReactHooksNotes","title":"React Hooks Notes","description":"- Reuse stateful logic between components","source":"@site/notes/Web/React/ReactHooksNotes.md","sourceDirName":"Web/React","slug":"/Web/React/ReactHooksNotes","permalink":"/awesome-notes/Web/React/ReactHooksNotes","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/awesome-notes/edit/main/notes/Web/React/ReactHooksNotes.md","tags":[{"inline":true,"label":"Web","permalink":"/awesome-notes/tags/web"},{"inline":true,"label":"React","permalink":"/awesome-notes/tags/react"}],"version":"current","lastUpdatedBy":"renovate[bot]","lastUpdatedAt":1734246257000,"frontMatter":{"author":"Sabertazimi","authorTitle":"Web Developer","authorURL":"https://github.com/sabertazimi","authorImageURL":"https://github.com/sabertazimi.png","tags":["Web","React"]},"sidebar":"tutorialSidebar","previous":{"title":"React Basic Notes","permalink":"/awesome-notes/Web/React/ReactBasicNotes"},"next":{"title":"React Router Basic Notes","permalink":"/awesome-notes/Web/React/ReactRouterBasicNotes"}}');var r=t(5105),o=t(842);const a={author:"Sabertazimi",authorTitle:"Web Developer",authorURL:"https://github.com/sabertazimi",authorImageURL:"https://github.com/sabertazimi.png",tags:["Web","React"]},i="React Hooks Notes",c={},l=[{value:"Hooks Types",id:"hooks-types",level:2},{value:"Hooks Memoized State",id:"hooks-memoized-state",level:2},{value:"Hooks Workflow",id:"hooks-workflow",level:2},{value:"Minimal Hooks Implementation",id:"minimal-hooks-implementation",level:2},{value:"UseState Hook",id:"usestate-hook",level:2},{value:"UseState Hooks Dispatcher",id:"usestate-hooks-dispatcher",level:3},{value:"UseState Hooks Usage",id:"usestate-hooks-usage",level:3},{value:"UseReducer Hook",id:"usereducer-hook",level:2},{value:"UseReducer Hooks Dispatcher",id:"usereducer-hooks-dispatcher",level:3},{value:"UseReducer Hooks Usage",id:"usereducer-hooks-usage",level:3},{value:"UseMemo Hook",id:"usememo-hook",level:2},{value:"UseMemo Hooks Dispatcher",id:"usememo-hooks-dispatcher",level:3},{value:"UseMemo Hooks Usage",id:"usememo-hooks-usage",level:3},{value:"UseCallback Hook",id:"usecallback-hook",level:2},{value:"UseCallback Hooks Dispatcher",id:"usecallback-hooks-dispatcher",level:3},{value:"UseCallback Hooks Usage",id:"usecallback-hooks-usage",level:3},{value:"UseRef Hook",id:"useref-hook",level:2},{value:"UseRef Hooks Dispatcher",id:"useref-hooks-dispatcher",level:3},{value:"Refs Features",id:"refs-features",level:3},{value:"Refs Update Mechanism",id:"refs-update-mechanism",level:3},{value:"Refs Usage",id:"refs-usage",level:3},{value:"UseContext Hook",id:"usecontext-hook",level:2},{value:"UseContext Hooks Dispatcher",id:"usecontext-hooks-dispatcher",level:3},{value:"UseContext Hooks Usage",id:"usecontext-hooks-usage",level:3},{value:"UseEffect Hook",id:"useeffect-hook",level:2},{value:"UseEffect Hooks Dispatcher",id:"useeffect-hooks-dispatcher",level:3},{value:"UseEffect Lifecycle",id:"useeffect-lifecycle",level:3},{value:"UseEffect Nasty Loop",id:"useeffect-nasty-loop",level:3},{value:"UseEffect Deps List",id:"useeffect-deps-list",level:3},{value:"UseEffect Omit Deps",id:"useeffect-omit-deps",level:4},{value:"UseEffect Primitive Deps",id:"useeffect-primitive-deps",level:4},{value:"UseEffect Functions Deps",id:"useeffect-functions-deps",level:4},{value:"UseEffect Compare Deps",id:"useeffect-compare-deps",level:4},{value:"UseEffect Closure",id:"useeffect-closure",level:3},{value:"UseEffect State",id:"useeffect-state",level:3},{value:"UseEffect Cleanup",id:"useeffect-cleanup",level:3},{value:"UseEffect Usage",id:"useeffect-usage",level:3},{value:"UseEffect Reference",id:"useeffect-reference",level:3},{value:"UseLayoutEffect Hook",id:"uselayouteffect-hook",level:2},{value:"UseInsertionEffect Hook",id:"useinsertioneffect-hook",level:2},{value:"UseImperativeHandle Hook",id:"useimperativehandle-hook",level:2},{value:"UseDebugValue Hook",id:"usedebugvalue-hook",level:2},{value:"UseDeferredValue Hook",id:"usedeferredvalue-hook",level:2},{value:"UseTransition Hook",id:"usetransition-hook",level:2},{value:"UseId Hook",id:"useid-hook",level:2},{value:"UseSyncExternalStore Hook",id:"usesyncexternalstore-hook",level:2},{value:"Sync Browser API",id:"sync-browser-api",level:3},{value:"Sync Browser Event",id:"sync-browser-event",level:3},{value:"Sync Browser Router",id:"sync-browser-router",level:3},{value:"Sync External State",id:"sync-external-state",level:3},{value:"UseEvent Hook",id:"useevent-hook",level:2},{value:"UseOptimistic Hook",id:"useoptimistic-hook",level:2},{value:"UseOptimistic Hooks Dispatcher",id:"useoptimistic-hooks-dispatcher",level:3},{value:"Custom Hooks",id:"custom-hooks",level:2},{value:"Custom LifeCycle Hooks",id:"custom-lifecycle-hooks",level:3},{value:"Custom Previous Hook",id:"custom-previous-hook",level:3},{value:"Custom Interval Hook",id:"custom-interval-hook",level:3},{value:"Custom Debounce Hook",id:"custom-debounce-hook",level:3},{value:"Custom EventListener Hook",id:"custom-eventlistener-hook",level:3},{value:"Custom Media Query Hook",id:"custom-media-query-hook",level:3},{value:"Custom Observer Hook",id:"custom-observer-hook",level:3},{value:"Custom Locked Body Hook",id:"custom-locked-body-hook",level:3},{value:"Custom Mouse Hook",id:"custom-mouse-hook",level:3},{value:"Custom Form Hook",id:"custom-form-hook",level:3},{value:"UseState Only Form Hook",id:"usestate-only-form-hook",level:4},{value:"UseState and UseRef Form Hook",id:"usestate-and-useref-form-hook",level:4},{value:"UseState and UseRef with DOM Refs Form Hook",id:"usestate-and-useref-with-dom-refs-form-hook",level:4},{value:"Custom URL Params Hook",id:"custom-url-params-hook",level:3},{value:"Custom Router Hook",id:"custom-router-hook",level:3},{value:"Custom History Hook",id:"custom-history-hook",level:3},{value:"Custom Script Loading Hook",id:"custom-script-loading-hook",level:3},{value:"Custom Cookie Hook",id:"custom-cookie-hook",level:3},{value:"Custom LocalStorage Hook",id:"custom-localstorage-hook",level:3},{value:"Custom Async Data Hook",id:"custom-async-data-hook",level:3},{value:"Custom Data Query Hook",id:"custom-data-query-hook",level:3},{value:"Custom Store Hook",id:"custom-store-hook",level:3},{value:"Custom Recoil Hook",id:"custom-recoil-hook",level:3},{value:"Custom Atom Hook",id:"custom-atom-hook",level:3},{value:"Custom Zustand Hook",id:"custom-zustand-hook",level:3},{value:"Hooks Best Practice",id:"hooks-best-practice",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"react-hooks-notes",children:"React Hooks Notes"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reuse stateful logic between components\n(avoid wrapper hell in render props or HOC)"}),"\n",(0,r.jsx)(n.li,{children:"Split one complex component into smaller functions"}),"\n",(0,r.jsxs)(n.li,{children:["Use more of React features ",(0,r.jsx)(n.strong,{children:"without classes"})]}),"\n",(0,r.jsxs)(n.li,{children:["Class components will read ",(0,r.jsx)(n.code,{children:"this.props"})," ",(0,r.jsx)(n.strong,{children:"too early"})," or ",(0,r.jsx)(n.strong,{children:"too late"}),",\nbecause of mutable ",(0,r.jsx)(n.code,{children:"this"})," in React\n(however ",(0,r.jsx)(n.code,{children:"props"})," argument of function components is immutable),\nthat says function components capture the ",(0,r.jsx)(n.strong,{children:"rendered values"}),".\nmore details on\n",(0,r.jsx)(n.a,{href:"https://overreacted.io/how-are-function-components-different-from-classes/",children:"Overreacted"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hooks-types",children:"Hooks Types"}),"\n",(0,r.jsxs)(n.p,{children:["Hooks\n",(0,r.jsx)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js",children:"definition"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u4ece React \u5185\u90e8 (Reconciler) \u770b, Hooks \u53ef\u5206\u4e3a\u4e09\u7c7b:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["State Hooks (",(0,r.jsx)(n.code,{children:"useState/useReducer/useContext/useRef/useCallback/useMemo"}),"):\n\u4e3b\u8981\u4f5c\u7528\u4e8e ",(0,r.jsx)(n.code,{children:"Reconciler.Render"})," \u9636\u6bb5, ",(0,r.jsx)(n.code,{children:"fiber.pendingProps/memoizedProps/memoizedState/updateQueue"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Effect Hooks (",(0,r.jsx)(n.code,{children:"useLayoutEffect"}),"/",(0,r.jsx)(n.code,{children:"useEffect"}),"):\n\u5728 ",(0,r.jsx)(n.code,{children:"Reconciler.Render"})," \u9636\u6bb5\u8bbe\u7f6e ",(0,r.jsx)(n.code,{children:"fiber.flags"})," (effects flags),\n\u4e3b\u8981\u4f5c\u7528\u4e8e ",(0,r.jsx)(n.code,{children:"Reconciler.Commit"})," \u9636\u6bb5, \u529f\u80fd\u63a5\u8fd1 ",(0,r.jsx)(n.code,{children:"ClassComponent.LifeCycle"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Hybrid Hooks (",(0,r.jsx)(n.code,{children:"useDeferredValue/useTransition/useId/useSyncExternalStore"}),"):\nState + Effect Hooks, \u65e2\u4fdd\u5b58\u72b6\u6001, \u53c8\u4ea7\u751f\u526f\u4f5c\u7528."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface Hook {\n  // hook \u4fdd\u5b58\u7684\u6570\u636e.\n  memoizedState: any\n  // \u672c\u6b21\u66f4\u65b0\u4ee5 baseState \u4e3a\u57fa\u7840\u8ba1\u7b97\u65b0\u7684 state.\n  baseState: any\n  // \u672c\u6b21\u66f4\u65b0\u5f00\u59cb\u65f6\u5df2\u6709\u7684 update \u961f\u5217.\n  baseQueue: Update<any, any> | null\n  // \u672c\u6b21\u66f4\u65b0\u9700\u8981\u589e\u52a0\u7684 update \u961f\u5217.\n  queue: UpdateQueue<any, any> | null\n  // \u6307\u5411\u4e0b\u4e00\u4e2a hook.\n  next: Hook | null\n}\n\ninterface Update<S, A> {\n  lane: Lane\n  action: A\n  hasEagerState: boolean\n  eagerState: S | null\n  next: Update<S, A>\n}\n\ninterface UpdateQueue<S, A> {\n  pending: Update<S, A> | null\n  interleaved: Update<S, A> | null\n  dispatch: ((A) => mixed) | null\n  lanes: Lanes\n  lastRenderedReducer: ((S, A) => S) | null\n  lastRenderedState: S | null\n}\n\ninterface Effect {\n  tag: HookFlags\n  create: () => (() => void) | void\n  destroy: (() => void) | void\n  deps: Array<mixed> | null\n  next: Effect\n}\n\ntype HookType =\n  | 'useState'\n  | 'useReducer'\n  | 'useContext'\n  | 'useRef'\n  | 'useEffect'\n  | 'useInsertionEffect'\n  | 'useLayoutEffect'\n  | 'useCallback'\n  | 'useMemo'\n  | 'useImperativeHandle'\n  | 'useDebugValue'\n  | 'useDeferredValue'\n  | 'useTransition'\n  | 'useMutableSource'\n  | 'useSyncExternalStore'\n  | 'useId'\n  | 'useCacheRefresh'\n"})}),"\n",(0,r.jsx)(n.h2,{id:"hooks-memoized-state",children:"Hooks Memoized State"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FunctionComponent"})," \u5185\u90e8\u6240\u6709 Hooks memoized state\n\u7ec4\u6210 ",(0,r.jsx)(n.code,{children:"FunctionComponent"})," ",(0,r.jsx)(n.code,{children:"Fiber"})," memoized state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FunctionComponent"})," ",(0,r.jsx)(n.code,{children:"Fiber"}),": ",(0,r.jsx)(n.code,{children:"fiber.memoizedState"})," \u6307\u5411\u7b2c\u4e00\u4e2a ",(0,r.jsx)(n.code,{children:"Hook"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Hooks"}),(0,r.jsx)(n.th,{children:"Memoized State"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"useRef"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ref: { current }"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"useMemo"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[nextValue, deps]"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"useCallback"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"[callback, deps]"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"useState"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"state"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"useEffect"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"effect: { tag, create, destroy, deps, next }"})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"hooks-workflow",children:"Hooks Workflow"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Reconciler.Render"}),"/",(0,r.jsx)(n.code,{children:"Reconciler.Update"}),":\n",(0,r.jsx)(n.code,{children:"performUnitOfWork"})," -> ",(0,r.jsx)(n.code,{children:"beginWork"})," -> ",(0,r.jsx)(n.code,{children:"updateFunctionComponent"}),"\n-> ",(0,r.jsx)(n.code,{children:"renderWithHooks"})," -> ",(0,r.jsx)(n.code,{children:"mountXXX"}),"/",(0,r.jsx)(n.code,{children:"updateXXX"}),"/",(0,r.jsx)(n.code,{children:"rerenderXXX"}),"\n-> ",(0,r.jsx)(n.code,{children:"reconcileChildren"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Reconciler.Commit"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Update"})," layout effect (",(0,r.jsx)(n.code,{children:"useLayoutEffect"}),"):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Mutation"})," phase: ",(0,r.jsx)(n.code,{children:"commitWork"})," -> ",(0,r.jsx)(n.code,{children:"commitHooKEffectListUnmount"})," -> ",(0,r.jsx)(n.code,{children:"effect.destroy"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Layout"})," phase: ",(0,r.jsx)(n.code,{children:"commitLifeCycles"})," -> ",(0,r.jsx)(n.code,{children:"commitHookEffectListMount"})," -> ",(0,r.jsx)(n.code,{children:"effect.create"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Update | Passive"})," passive effect (",(0,r.jsx)(n.code,{children:"useEffect"}),"):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Layout"})," phase: ",(0,r.jsx)(n.code,{children:"commitLifeCycles"})," -> ",(0,r.jsx)(n.code,{children:"schedulePassiveEffects"}),", \u6536\u96c6 Effects."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scheduleCallback"})," -> ",(0,r.jsx)(n.code,{children:"flushPassiveEffects"})," -> ",(0,r.jsx)(n.code,{children:"effect.destroy"})," -> ",(0,r.jsx)(n.code,{children:"effect.create"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\u53ea\u6709 ",(0,r.jsx)(n.code,{children:"effect.tag"})," \u5305\u542b ",(0,r.jsx)(n.code,{children:"HasEffect"})," \u65f6\u624d\u4f1a\u8c03\u7528 ",(0,r.jsx)(n.code,{children:"effect.destroy"})," \u548c ",(0,r.jsx)(n.code,{children:"effect.create"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"renderWithHooks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HooksDispatcherOnMount"}),": ",(0,r.jsx)(n.code,{children:"mountXXX"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HooksDispatcherOnUpdate"}),": ",(0,r.jsx)(n.code,{children:"updateXXX"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HooksDispatcherOnRerender"}),": ",(0,r.jsx)(n.code,{children:"updateXXX"}),"/",(0,r.jsx)(n.code,{children:"rerenderXXX"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mountXXX"})}),": ",(0,r.jsx)(n.code,{children:"mountWorkInProgressHook"})," -> respective mount logic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"updateXXX"})}),": ",(0,r.jsx)(n.code,{children:"updateWorkInProgressHook"})," -> respective update logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.new.js",children:"ReactReconciler/ReactFiberBeginWork"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n): Fiber | null {\n  const updateLanes = workInProgress.lanes\n\n  switch (workInProgress.tag) {\n    case FunctionComponent: {\n      const Component = workInProgress.type\n      const unresolvedProps = workInProgress.pendingProps\n      const resolvedProps\n        = workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps)\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes\n      )\n    }\n  }\n}\n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderLanes\n) {\n  const context = prepareToReadContext(workInProgress, renderLanes)\n\n  // \u8fdb\u5165 Hooks \u76f8\u5173\u903b\u8f91, \u6700\u540e\u8fd4\u56de\u4e0b\u7ea7 ReactElement \u5bf9\u8c61.\n  const nextChildren = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    context,\n    renderLanes\n  )\n\n  const hasId = checkDidRenderIdHook()\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes)\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n  }\n\n  if (getIsHydrating() && hasId)\n    pushMaterializedTreeId(workInProgress)\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork\n\n  // \u8fdb\u5165 Reconcile \u51fd\u6570, \u751f\u6210\u4e0b\u7ea7 Fiber \u8282\u70b9.\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes)\n  // \u8fd4\u56de\u4e0b\u7ea7 Fiber \u8282\u70b9.\n  return workInProgress.child\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js",children:"ReactReconciler/ReactFiberHooks"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// \u6e32\u67d3\u4f18\u5148\u7ea7.\nlet renderLanes: Lanes = NoLanes\n\n// \u5f53\u524d\u6b63\u5728\u6784\u9020\u7684 Fiber, \u7b49\u540c\u4e8e workInProgress.\nlet currentlyRenderingFiber: Fiber = null\n\n// Hooks \u94fe\u8868\u88ab\u5b58\u50a8\u5728 fiber.memoizedState:\n// currentHook = fiber(current).memoizedState.\nlet currentHook: Hook | null = null\n// workInProgressHook = fiber(workInProgress).memoizedState.\nlet workInProgressHook: Hook | null = null\n\n// \u5728 FunctionComponent \u7684\u6267\u884c\u8fc7\u7a0b\u4e2d, \u662f\u5426\u518d\u6b21\u53d1\u8d77\u4e86\u66f4\u65b0.\n// \u53ea\u6709 FunctionComponent \u88ab\u5b8c\u5168\u6267\u884c\u4e4b\u540e\u624d\u4f1a\u91cd\u7f6e.\n// \u5f53 render \u5f02\u5e38\u65f6, \u901a\u8fc7\u8be5\u53d8\u91cf\u53ef\u4ee5\u51b3\u5b9a\u662f\u5426\u6e05\u9664 render \u8fc7\u7a0b\u4e2d\u7684\u66f4\u65b0.\nlet didScheduleRenderPhaseUpdate = false\n\n// \u5728\u672c\u6b21 FunctionComponent \u7684\u6267\u884c\u8fc7\u7a0b\u4e2d, \u662f\u5426\u518d\u6b21\u53d1\u8d77\u4e86\u66f4\u65b0.\n// \u6bcf\u4e00\u6b21\u8c03\u7528 FunctionComponent \u90fd\u4f1a\u88ab\u91cd\u7f6e.\nlet didScheduleRenderPhaseUpdateDuringThisPass = false\n\n// \u5728\u672c\u6b21 FunctionComponent \u7684\u6267\u884c\u8fc7\u7a0b\u4e2d, \u91cd\u65b0\u53d1\u8d77\u66f4\u65b0\u7684\u6700\u5927\u6b21\u6570.\nconst RE_RENDER_LIMIT = 25\n\nexport function renderWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes\n): any {\n  // Store context.\n  renderLanes = nextRenderLanes\n  currentlyRenderingFiber = workInProgress\n\n  workInProgress.memoizedState = null\n  workInProgress.updateQueue = null\n  workInProgress.lanes = NoLanes\n\n  // Mount or Update hooks dispatcher.\n  ReactCurrentDispatcher.current\n    = current === null || current.memoizedState === null\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate\n\n  // \u6267\u884c FunctionComponent \u51fd\u6570, \u6267\u884c `useXXX`.\n  let children = Component(props, secondArg)\n\n  // Check if there was a render phase update\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue.\n    // Use a counter to prevent infinite loops.\n    let numberOfReRenders = 0\n\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false\n      localIdCounter = 0\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error(\n          'Too many re-renders. React limits the number of renders to prevent '\n          + 'an infinite loop.'\n        )\n      }\n\n      numberOfReRenders += 1\n\n      // Start over from the beginning of the list\n      currentHook = null\n      workInProgressHook = null\n      workInProgress.updateQueue = null\n      // Rerender hooks dispatcher.\n      ReactCurrentDispatcher.current = HooksDispatcherOnRerender\n\n      children = Component(props, secondArg)\n    } while (didScheduleRenderPhaseUpdateDuringThisPass)\n  }\n\n  // Restore context.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher\n  renderLanes = NoLanes\n  currentlyRenderingFiber = null\n  currentHook = null\n  workInProgressHook = null\n  didScheduleRenderPhaseUpdate = false\n\n  return children\n}\n\nconst HooksDispatcherOnMount: Dispatcher = {\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useInsertionEffect: mountInsertionEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n  useMutableSource: mountMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: mountId,\n  unstable_isNewReconciler: enableNewReconciler,\n  readContext,\n}\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n  unstable_isNewReconciler: enableNewReconciler,\n  readContext,\n}\n\nconst HooksDispatcherOnRerender: Dispatcher = {\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n  unstable_isNewReconciler: enableNewReconciler,\n  readContext,\n}\n\n// \u521b\u5efa Hook, \u6302\u8f7d\u5230 Hooks \u94fe\u8868.\nfunction mountWorkInProgressHook(): Hook {\n  // hook \u5b9e\u4f8b\n  const hook: Hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: hookForB,\n  }\n\n  if (workInProgressHook === null) {\n    // Fist hook in the list.\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook\n  } else {\n    // Append to the end of list.\n    workInProgressHook = workInProgressHook.next = hook\n  }\n\n  return workInProgressHook\n}\n\n// \u79fb\u52a8 Hooks \u94fe\u8868\u6307\u9488, \u83b7\u53d6 workInProgressHook.\nfunction updateWorkInProgressHook(): Hook {\n  let nextCurrentHook: Hook | null\n  let nextWorkInProgressHook: Hook | null\n\n  if (currentHook === null) {\n    const current = currentlyRenderingFiber.alternate\n    nextCurrentHook = current ? current.memoizedState : null\n  } else {\n    nextCurrentHook = currentHook.next\n  }\n\n  if (workInProgressHook === null)\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState\n  else nextWorkInProgressHook = workInProgressHook.next\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook\n    nextWorkInProgressHook = workInProgressHook.next\n    currentHook = nextCurrentHook\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null)\n      throw new Error('Rendered more hooks than during the previous render.')\n\n    currentHook = nextCurrentHook\n\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n\n      next: null,\n    }\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook\n    }\n  }\n\n  return workInProgressHook\n}\n\nfunction commitHookEffectListMount(tag: number, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null\n    = finishedWork.updateQueue\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next\n    let effect = firstEffect\n\n    do {\n      if ((effect.tag & tag) === tag) {\n        const create = effect.create\n        effect.destroy = create()\n      }\n\n      effect = effect.next\n    } while (effect !== firstEffect)\n  }\n}\n\nfunction commitHookEffectListUnmount(tag: number, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null\n    = finishedWork.updateQueue\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next\n    let effect = firstEffect\n\n    do {\n      if ((effect.tag & tag) === tag) {\n        // \u6839\u636e\u4f20\u5165\u7684 tag \u8fc7\u6ee4 Effects \u94fe\u8868.\n        const destroy = effect.destroy\n        effect.destroy = undefined\n\n        if (destroy !== undefined)\n          destroy()\n      }\n\n      effect = effect.next\n    } while (effect !== firstEffect)\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"minimal-hooks-implementation",children:"Minimal Hooks Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const MyReact = (function () {\n  const hooks = []\n  let currentHook = 0 // array of hooks, and an iterator!\n  return {\n    render(Component) {\n      const Comp = Component() // run effects\n      Comp.render()\n      currentHook = 0 // reset for next render\n      return Comp\n    },\n    useEffect(callback, depArray) {\n      const hasNoDeps = !depArray\n      const deps = hooks[currentHook] // type: array | undefined\n      const hasChangedDeps = deps\n        ? !depArray.every((el, i) => el === deps[i])\n        : true\n      if (hasNoDeps || hasChangedDeps) {\n        callback()\n        hooks[currentHook] = depArray\n      }\n      currentHook++ // done with this hook\n    },\n    useState(initialValue) {\n      hooks[currentHook] = hooks[currentHook] || initialValue // type: any\n      const setStateHookIndex = currentHook // for setState's closure!\n      const setState = newState => (hooks[setStateHookIndex] = newState)\n      return [hooks[currentHook++], setState]\n    },\n  }\n})()\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function Counter() {\n  const [count, setCount] = MyReact.useState(0)\n  const [text, setText] = MyReact.useState('foo') // 2nd state hook!\n  MyReact.useEffect(() => {\n    console.log('effect', count, text)\n  }, [count, text])\n  return {\n    click: () => setCount(count + 1),\n    type: txt => setText(txt),\n    noop: () => setCount(count),\n    render: () => console.log('render', { count, text }),\n  }\n}\n\nlet App\n\nApp = MyReact.render(Counter)\n// effect 0 foo\n// render {count: 0, text: 'foo'}\n\nApp.click()\nApp = MyReact.render(Counter)\n// effect 1 foo\n// render {count: 1, text: 'foo'}\n\nApp.type('bar')\nApp = MyReact.render(Counter)\n// effect 1 bar\n// render {count: 1, text: 'bar'}\n\nApp.noop()\nApp = MyReact.render(Counter)\n// // no effect run\n// render {count: 1, text: 'bar'}\n\nApp.click()\nApp = MyReact.render(Counter)\n// effect 2 bar\n// render {count: 2, text: 'bar'}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function Component() {\n  const [text, setText] = useSplitURL('www.netlify.com')\n  return {\n    type: txt => setText(txt),\n    render: () => console.log({ text }),\n  }\n}\n\nfunction useSplitURL(str) {\n  const [text, setText] = MyReact.useState(str)\n  const masked = text.split('.')\n  return [masked, setText]\n}\n\nlet App\n\nApp = MyReact.render(Component)\n// { text: [ 'www', 'netlify', 'com' ] }\n\nApp.type('www.reactjs.org')\nApp = MyReact.render(Component)\n// { text: [ 'www', 'reactjs', 'org' ] }}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usestate-hook",children:"UseState Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Read rendered props/state."}),"\n",(0,r.jsxs)(n.li,{children:["Return value of ",(0,r.jsx)(n.code,{children:"useState"})," is ",(0,r.jsx)(n.code,{children:"ref"})," to ",(0,r.jsx)(n.code,{children:"hooks[idx]"}),":\ndirect change to return value doesn't change state value."]}),"\n",(0,r.jsxs)(n.li,{children:["Return function of ",(0,r.jsx)(n.code,{children:"useState"})," (",(0,r.jsx)(n.code,{children:"setState"}),") is to change value of ",(0,r.jsx)(n.code,{children:"hooks[idx]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["\u7531\u4e8e setState \u66f4\u65b0\u72b6\u6001 (dispatch action) \u65f6\u57fa\u4e8e hook.BaseState,\n",(0,r.jsx)(n.code,{children:"setState(value + 1)"})," \u4e0e ",(0,r.jsx)(n.code,{children:"setState(value => value + 1)"})," \u5b58\u5728\u5dee\u5f02."]}),"\n",(0,r.jsxs)(n.li,{children:["\u5f53\u5728 useEffect \u4e2d\u8c03\u7528 setState \u65f6, \u6700\u597d\u4f7f\u7528 ",(0,r.jsx)(n.code,{children:"setState(callback)"})," \u5f62\u5f0f,\n\u8fd9\u6837\u53ef\u4ee5\u4e0d\u7528\u518d Deps List \u4e2d\u663e\u5f0f\u58f0\u660e state, \u4e5f\u53ef\u4ee5\u907f\u514d\u4e00\u4e9b BUG."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dispatchAction"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u521b\u5efa ",(0,r.jsx)(n.code,{children:"Update"})," \u5bf9\u8c61."]}),"\n",(0,r.jsx)(n.li,{children:"\u5c06 Update \u5bf9\u8c61\u6dfb\u52a0\u5230 hook.queue.pending \u961f\u5217."}),"\n",(0,r.jsx)(n.li,{children:"\u6839\u636e reducerEagerState \u4e0e currentState, \u51b3\u5b9a\u662f\u5426\u53d1\u8d77\u65b0\u7684 Reconciler \u8c03\u5ea6."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usestate-hooks-dispatcher",children:"UseState Hooks Dispatcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountState<T>(initialState: T) {\n  const hook = mountWorkInProgressHook()\n\n  if (typeof initialState === 'function')\n    initialState = initialState()\n\n  // Setup Hook.\n  hook.memoizedState = hook.baseState = initialState\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState,\n  })\n  const dispatch = (queue.dispatch = dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue\n  ))\n\n  // Return Hook state and dispatch action.\n  return [hook.memoizedState, dispatch]\n}\n\nfunction updateState<T>(initialState: T) {\n  const basicStateReducer = (state, action) => {\n    return typeof action === 'function' ? action(state) : action\n  }\n\n  return updateReducer(basicStateReducer)\n}\n\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A\n) {\n  // 1. \u521b\u5efa Update \u5bf9\u8c61.\n  const eventTime = requestEventTime()\n  const lane = requestUpdateLane(fiber)\n  const update: Update<S, A> = {\n    lane,\n    action,\n    eagerReducer: null,\n    eagerState: null,\n    next: null,\n  }\n\n  // 2. \u5c06 Update \u5bf9\u8c61\u6dfb\u52a0\u5230 hook.queue.pending \u961f\u5217.\n  const pending = queue.pending\n  if (pending === null) {\n    // \u9996\u4e2a Update, \u521b\u5efa\u4e00\u4e2a\u73af\u5f62\u94fe\u8868.\n    update.next = update\n  } else {\n    update.next = pending.next\n    pending.next = update\n  }\n  queue.pending = update\n\n  const alternate = fiber.alternate\n  if (\n    fiber === currentlyRenderingFiber\n    || (alternate !== null && alternate === currentlyRenderingFiber)\n  ) {\n    // \u6e32\u67d3\u65f6\u66f4\u65b0, \u505a\u597d\u5168\u5c40\u6807\u8bb0.\n    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate\n      = true\n  } else {\n    if (\n      fiber.lanes === NoLanes\n      && (alternate === null || alternate.lanes === NoLanes)\n    ) {\n      const lastRenderedReducer = queue.lastRenderedReducer\n\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher\n        const currentState: S = queue.lastRenderedState\n        const eagerState = lastRenderedReducer(currentState, action)\n        update.eagerReducer = lastRenderedReducer\n        update.eagerState = eagerState\n\n        // \u82e5\u5728 Render \u9636\u6bb5, reducerEagerState === currentState,\n        // \u5219\u53ef\u4ee5\u65e0\u9700\u518d\u6b21\u8ba1\u7b97\u72b6\u6001, \u8df3\u8fc7\u8c03\u5ea6\u9636\u6bb5, \u540e\u7eed\u76f4\u63a5\u4f7f\u7528 update.eagerState.\n        if (is(eagerState, currentState))\n          return\n      }\n    }\n\n    // 3. \u53d1\u8d77\u8c03\u5ea6\u66f4\u65b0, \u8fdb\u5165 Reconciler.\n    scheduleUpdateOnFiber(fiber, lane, eventTime)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://react.dev/learn/queueing-a-series-of-state-updates",children:"Queueing series of state updates"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function getFinalState(baseState, queue) {\n  let finalState = baseState\n\n  for (const update of queue)\n    finalState = typeof update === 'function' ? update(finalState) : update\n\n  return finalState\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usestate-hooks-usage",children:"UseState Hooks Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"setState((prevState) => {\n  // Object.assign would also work\n  return { ...prevState, ...updatedValues }\n})\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"let newState = baseState\nconst firstUpdate = hook.baseQueue.next\nlet update = firstUpdate\n\n// setState(value + 1) \u4e0e setState(value => value + 1) \u5b58\u5728\u5dee\u5f02\n// \u904d\u5386 baseQueue \u4e2d\u7684\u6bcf\u4e00\u4e2a update\ndo {\n  if (typeof update.action === 'function')\n    newState = update.action(newState)\n  else newState = action\n\n  update = reconciler()\n} while (update !== firstUpdate)\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\n\nexport default function Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0)\n\n  return (\n    <div>\n      <p>\n        You clicked\n        {' '}\n        {count}\n        {' '}\n        times\n      </p>\n      <button type=\"button\" onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect, useState } from 'react'\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null)\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline)\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)\n\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)\n    }\n  })\n\n  if (isOnline === null)\n    return 'Loading...'\n\n  return isOnline ? 'Online' : 'Offline'\n}\n\n// Mount with { friend: { id: 100 } } props\nChatAPI.subscribeToFriendStatus(100, handleStatusChange) // Run first effect\n\n// Update with { friend: { id: 200 } } props\n// Clean up previous effect\nChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange)\nChatAPI.subscribeToFriendStatus(200, handleStatusChange) // Run next effect\n\n// Update with { friend: { id: 300 } } props\n// Clean up previous effect\nChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange)\nChatAPI.subscribeToFriendStatus(300, handleStatusChange) // Run next effect\n\n// Unmount\nChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange) // Clean up last effect\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usereducer-hook",children:"UseReducer Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use useState whenever manage a JS ",(0,r.jsx)(n.strong,{children:"primitive"})," (e.g. string, boolean, integer)."]}),"\n",(0,r.jsxs)(n.li,{children:["Use useReducer whenever manage an ",(0,r.jsx)(n.strong,{children:"object"})," or ",(0,r.jsx)(n.strong,{children:"array"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"It\u2019s best to put states together in one state object\nwhen they conditionally dependent on each other (useReducer)."}),"\n",(0,r.jsx)(n.li,{children:"Using useReducer over useState gives us predictable state transitions.\nIt comes in very powerful when state changes become more complex."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usereducer-hooks-dispatcher",children:"UseReducer Hooks Dispatcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: (I) => S\n): [S, Dispatch<A>] {\n  // 1. Create Hook.\n  const hook = mountWorkInProgressHook()\n  let initialState\n\n  if (init !== undefined)\n    initialState = init(initialArg)\n  else initialState = initialArg\n\n  // 2. Setup Hook.\n  // 2.1 Set hook.memoizedState/hook.baseState.\n  hook.memoizedState = hook.baseState = initialState\n  // 2.2 Set hook.queue.\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState,\n  })\n  // 2.3 Set hook.dispatch.\n  const dispatch: Dispatch<A> = (queue.dispatch = dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue\n  ))\n\n  // 3. Return Hook state and dispatch action.\n  return [hook.memoizedState, dispatch]\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: (I) => S\n): [S, Dispatch<A>] {\n  // Get workInProgressHook.\n  const hook = updateWorkInProgressHook()\n  const queue = hook.queue\n  queue.lastRenderedReducer = reducer\n  const current: Hook = currentHook\n\n  // The last rebase update that is NOT part of the base state.\n  let baseQueue = current.baseQueue\n  // The last pending update that hasn't been processed yet.\n  const pendingQueue = queue.pending\n\n  // Append hook.queue.pending to current.baseQueue.\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next\n      const pendingFirst = pendingQueue.next\n      baseQueue.next = pendingFirst\n      pendingQueue.next = baseFirst\n    }\n\n    current.baseQueue = baseQueue = pendingQueue\n    queue.pending = null\n  }\n\n  // Calculate Hook state.\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next\n    let newState = current.baseState\n\n    let newBaseState = null\n    let newBaseQueueFirst = null\n    let newBaseQueueLast = null\n    let update = first\n\n    do {\n      const updateLane = update.lane\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // \u4f18\u5148\u7ea7\u4e0d\u591f: \u52a0\u5165\u5230 baseQueue, \u7b49\u5f85\u4e0b\u4e00\u6b21 render.\n        const clone: Update<S, A> = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null,\n        }\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone\n          newBaseState = newState\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone\n        }\n\n        // Update the remaining priority in the queue.\n        currentlyRenderingFiber.lanes = mergeLanes(\n          currentlyRenderingFiber.lanes,\n          updateLane\n        )\n        markSkippedUpdateLanes(updateLane)\n      } else {\n        // This update does have sufficient priority (\u4f18\u5148\u7ea7\u8db3\u591f).\n        // Merge state.\n        if (newBaseQueueLast !== null) {\n          // Update baseQueue\n          const clone: Update<S, A> = {\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null,\n          }\n          newBaseQueueLast = newBaseQueueLast.next = clone\n        }\n\n        // Process this update.\n        if (update.hasEagerState) {\n          // \u6027\u80fd\u4f18\u5316:\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState\n        } else {\n          // \u8c03\u7528 Reducer \u83b7\u53d6\u6700\u65b0\u72b6\u6001.\n          const action = update.action\n          newState = reducer(newState, action)\n        }\n      }\n\n      update = update.next\n    } while (update !== null && update !== first)\n\n    if (newBaseQueueLast === null)\n      newBaseState = newState\n    else newBaseQueueLast.next = newBaseQueueFirst\n\n    // Mark that the fiber performed work,\n    // but only if the new state is different from the current state.\n    if (!is(newState, hook.memoizedState))\n      markWorkInProgressReceivedUpdate()\n\n    // \u628a\u8ba1\u7b97\u540e\u7ed3\u679c\u66f4\u65b0\u5230 workInProgressHook.\n    hook.memoizedState = newState\n    hook.baseState = newBaseState\n    hook.baseQueue = newBaseQueueLast\n    queue.lastRenderedState = newState\n  }\n\n  // Return Hook state and dispatch action.\n  const dispatch: Dispatch<A> = queue.dispatch\n  return [hook.memoizedState, dispatch]\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usereducer-hooks-usage",children:"UseReducer Hooks Usage"}),"\n",(0,r.jsx)(n.p,{children:"Use useState if:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"manage JavaScript primitives as state"}),"\n",(0,r.jsx)(n.li,{children:"have simple state transitions"}),"\n",(0,r.jsx)(n.li,{children:"want to have business logic within components"}),"\n",(0,r.jsx)(n.li,{children:"have different properties that don\u2019t change in any correlated manner\nand can be managed by multiple useState hooks"}),"\n",(0,r.jsx)(n.li,{children:"state is co-located to your component"}),"\n",(0,r.jsx)(n.li,{children:"for a small application"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Use useReducer if:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"manage JavaScript objects or arrays as state"}),"\n",(0,r.jsx)(n.li,{children:"have complex state transitions"}),"\n",(0,r.jsx)(n.li,{children:"want to move business logic into reducers"}),"\n",(0,r.jsx)(n.li,{children:"have different properties that are tied together\nand should be managed in one state object"}),"\n",(0,r.jsx)(n.li,{children:"update state deep down in your component tree"}),"\n",(0,r.jsx)(n.li,{children:"for a medium size application"}),"\n",(0,r.jsx)(n.li,{children:"for easier testing"}),"\n",(0,r.jsx)(n.li,{children:"for more predictable and maintainable state architecture"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function App() {\n  const [state, dispatch] = useState({ count: 0 })\n\n  // \u7b49\u4ef7\u4e8e\n  const [state, dispatch] = useReducer(\n    (state, action) => {\n      return typeof action === 'function' ? action(state) : action\n    },\n    { count: 0 }\n  )\n\n  // \u5f53\u9700\u8981\u66f4\u65b0 state \u65f6, \u6709 2 \u79cd\u65b9\u5f0f:\n  // 1. \u76f4\u63a5\u8bbe\u7f6e:\n  dispatch({ count: 1 })\n  // 2.\u901a\u8fc7\u56de\u8c03\u51fd\u6570\u8bbe\u7f6e:\n  dispatch(state => ({ count: state.count + 1 }))\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function insertToHistory(state) {\n  if (state && Array.isArray(state.history)) {\n    // Do not mutate\n    const newHistory = [...state.history]\n    newHistory.push(state)\n    return newHistory\n  }\n  console.warn(`\n    WARNING! The state was attempting capture but something went wrong.\n    Please check if the state is controlled correctly.\n  `)\n  return state.history || []\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'set-theme':\n      return { ...state, theme: action.theme, history: insertToHistory(state) }\n    case 'add-friend':\n      return {\n        ...state,\n        friends: [...state.friends, action.friend],\n        history: insertToHistory(state),\n      }\n    case 'undo': {\n      const isEmpty = !state.history.length\n      if (isEmpty)\n        return state\n      return { ...state.history[state.history.length - 1] }\n    }\n    case 'reset':\n      return { ...initialState, history: insertToHistory(state) }\n    default:\n      return state\n  }\n}\n\nexport default function App() {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  return <div>App</div>\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usememo-hook",children:"UseMemo Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns a memoized value."}),"\n",(0,r.jsx)(n.li,{children:"Only recompute the memoized value when one of the dependencies has changed."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shallow compare"})," diff."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimization"})," helps to\navoid expensive calculations on every render\n(avoid re-render problem):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Good use"})," for complex objects or expensive calculations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Donn't use"})," for primitive values or simple calculations."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usememo-hooks-dispatcher",children:"UseMemo Hooks Dispatcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null\n): T {\n  const hook = mountWorkInProgressHook()\n  const nextDeps = deps === undefined ? null : deps\n  const nextValue = nextCreate()\n  hook.memoizedState = [nextValue, nextDeps]\n  return nextValue\n}\n\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null\n): T {\n  const hook = updateWorkInProgressHook()\n  const nextDeps = deps === undefined ? null : deps\n  const prevState = hook.memoizedState\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1]\n\n      if (areHookInputsEqual(nextDeps, prevDeps))\n        return prevState[0]\n    }\n  }\n\n  const nextValue = nextCreate()\n  hook.memoizedState = [nextValue, nextDeps]\n  return nextValue\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usememo-hooks-usage",children:"UseMemo Hooks Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'export default function Button({\n  color,\n  children,\n}: {\n  color: string\n  children: ReactElement\n}) {\n  const textColor = useMemo(\n    () => slowlyCalculateTextColor(color),\n    [color] // \u2705 Don\u2019t recalculate until `color` changes\n  )\n\n  return (\n    <button type="button" className={`Button-${color} Button-text-${textColor}`}>\n      {children}\n    </button>\n  )\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"usecallback-hook",children:"UseCallback Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns a memoized callback."}),"\n",(0,r.jsxs)(n.li,{children:["\u5bf9\u4e8b\u4ef6\u53e5\u67c4\u8fdb\u884c\u7f13\u5b58, ",(0,r.jsx)(n.code,{children:"useState"})," \u7684\u7b2c\u4e8c\u4e2a\u8fd4\u56de\u503c\u662f ",(0,r.jsx)(n.code,{children:"dispatch"}),",\n\u4f46\u662f\u6bcf\u6b21\u90fd\u662f\u8fd4\u56de\u65b0\u7684\u51fd\u6570, \u4f7f\u7528 ",(0,r.jsx)(n.code,{children:"useCallback"}),", \u53ef\u4ee5\u8ba9\u5b83\u4f7f\u7528\u4e0a\u6b21\u7684\u51fd\u6570.\n\u5728\u865a\u62df DOM \u66f4\u65b0\u8fc7\u7a0b\u4e2d, \u5982\u679c\u4e8b\u4ef6\u53e5\u67c4\u76f8\u540c, \u90a3\u4e48\u5c31\u4e0d\u7528\u6bcf\u6b21\u90fd\u8fdb\u884c\n",(0,r.jsx)(n.code,{children:"removeEventListener"})," \u4e0e ",(0,r.jsx)(n.code,{children:"addEventListener"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useCallback(fn, deps)"})," is equivalent to ",(0,r.jsx)(n.code,{children:"useMemo(() => fn, deps)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usecallback-hooks-dispatcher",children:"UseCallback Hooks Dispatcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook()\n  const nextDeps = deps === undefined ? null : deps\n  hook.memoizedState = [callback, nextDeps]\n  return callback\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook()\n  const nextDeps = deps === undefined ? null : deps\n  const prevState = hook.memoizedState\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1]\n\n      if (areHookInputsEqual(nextDeps, prevDeps))\n        return prevState[0]\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps]\n  return callback\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usecallback-hooks-usage",children:"UseCallback Hooks Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Parent() {\n  const [query, setQuery] = useState('react')\n\n  // \u2705 Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = `https://hn.algolia.com/api/v1/search?query=${query}`\n    // ... Fetch data and return it ...\n  }, [query]) // \u2705 Callback deps are OK\n\n  return <Child fetchData={fetchData} />\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Child({ fetchData }) {\n  const [data, setData] = useState(null)\n\n  useEffect(() => {\n    fetchData().then(setData)\n  }, [fetchData]) // \u2705 Effect deps are OK\n\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"useref-hook",children:"UseRef Hook"}),"\n",(0,r.jsx)(n.h3,{id:"useref-hooks-dispatcher",children:"UseRef Hooks Dispatcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountRef<T>(initialValue: T) {\n  const hook = mountWorkInProgressHook()\n  const ref = {\n    current: initialValue,\n  }\n  Object.seal(ref)\n  hook.memoizedState = ref\n  return ref\n}\n\nfunction updateRef<T>(initialValue: T) {\n  const hook = updateWorkInProgressHook()\n  return hook.memoizedState\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"refs-features",children:"Refs Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Mutable Value:\n",(0,r.jsx)(n.code,{children:"useRef()"})," is useful for for keeping any mutable value around.\nUpdating reference values inside handlers/useEffect callbacks is good,\nupdating reference values during rendering (outside callbacks) is bad."]}),"\n",(0,r.jsxs)(n.li,{children:["Lifecycle Persisted Value:\n",(0,r.jsx)(n.code,{children:"useRef()"})," creates a plain JavaScript object,\nis persisted (",(0,r.jsx)(n.strong,{children:"stays the same"}),") between component re-renderings."]}),"\n",(0,r.jsx)(n.li,{children:"Silent Value:\nupdate reference values don't trigger re-renderings."}),"\n",(0,r.jsxs)(n.li,{children:["Latest Value:\n",(0,r.jsx)(n.code,{children:"useRef()"})," read rendered props/state from ",(0,r.jsx)(n.strong,{children:"the future"}),".\nIt's good to get ",(0,r.jsx)(n.strong,{children:"latest"})," value of a particular prop or state\n(the updated reference value is available right away)."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Example() {\n  const [count, setCount] = useState(0)\n  const latestCount = useRef(count)\n\n  useEffect(() => {\n    // Set the mutable latest value\n    latestCount.current = count\n    setTimeout(() => {\n      // Read the mutable latest value\n      console.log(`You clicked ${latestCount.current} times`)\n    }, 3000)\n  })\n\n  return <div>Example</div>\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"refs-update-mechanism",children:"Refs Update Mechanism"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Update a ",(0,r.jsx)(n.code,{children:"ref"}),", no re-renderings happens."]}),"\n",(0,r.jsxs)(n.li,{children:["Update a ",(0,r.jsx)(n.code,{children:"state"}),", the deep rendering mechanism works to re-render components."]}),"\n",(0,r.jsxs)(n.li,{children:["Store values in refs and have them updated,\nwhich is more ",(0,r.jsx)(n.strong,{children:"efficient"})," than ",(0,r.jsx)(n.code,{children:"useState"})," (which can be expensive)\nwhen the values are to be updated multiple times within a second."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'export default function UserAvatar({ src }: { src: string }) {\n  return <img src={src} alt="User Avatar" />\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Username({ name }: { name: string }) {\n  return <span>{name}</span>\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function User() {\n  const user = useRef({\n    name: 'UserName',\n    avatarURL: 'https://avatar.com/avatar',\n  })\n\n  useEffect(() => {\n    setTimeout(() => {\n      user.current = {\n        name: 'NewUserName',\n        avatarURL: 'https://avatar.com/newavatar',\n      }\n    }, 5000)\n  })\n\n  // Only output once\n  console.log('Rendered.')\n\n  // Both children won't be re-rendered\n  // due to shallow rendering mechanism\n  return (\n    <div>\n      <Username name={user.name} />\n      <UserAvatar src={user.avatarURL} />\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"refs-usage",children:"Refs Usage"}),"\n",(0,r.jsxs)(n.p,{children:["If your component needs to store some value,\nbut it doesn\u2019t impact the rendering logic,\n",(0,r.jsx)(n.a,{href:"https://react.dev/learn/referencing-values-with-refs#when-to-use-refs",children:"choose refs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Storing timeout IDs."}),"\n",(0,r.jsx)(n.li,{children:"Storing and manipulating DOM elements (binding to HTMLElement)."}),"\n",(0,r.jsx)(n.li,{children:"Storing other objects that aren\u2019t necessary to calculate the JSX:\nwork with external systems or browser APIs."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ref"})," can either be a state that does not need to change too often."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ref"})," can either be a state that should change as frequently as possible\nbut should not trigger full re-rendering of the component."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { useRef, useState } from \'react\'\n\nexport default function Stopwatch() {\n  const [startTime, setStartTime] = useState(null)\n  const [now, setNow] = useState(null)\n  const intervalRef = useRef(null)\n\n  function handleStart() {\n    setStartTime(Date.now())\n    setNow(Date.now())\n\n    clearInterval(intervalRef.current)\n    intervalRef.current = setInterval(() => {\n      setNow(Date.now())\n    }, 10)\n  }\n\n  function handleStop() {\n    clearInterval(intervalRef.current)\n  }\n\n  let secondsPassed = 0\n  if (startTime != null && now != null)\n    secondsPassed = (now - startTime) / 1000\n\n  return (\n    <>\n      <h1>\n        Time passed:\n        {secondsPassed.toFixed(3)}\n      </h1>\n      <button type="button" onClick={handleStart}>Start</button>\n      <button type="button" onClick={handleStop}>Stop</button>\n    </>\n  )\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { forwardRef, useImperativeHandle, useRef } from 'react'\n\ninterface Props {}\n\nfunction MyInput({ ref, ...props }: Props) {\n  const realInputRef = useRef(null)\n  useImperativeHandle(ref, () => ({\n    // Only expose focus and nothing else\n    focus() {\n      realInputRef.current.focus()\n    },\n  }))\n  return <input {...props} ref={realInputRef} />\n}\n\nexport default function Form() {\n  const inputRef = useRef(null)\n\n  function handleClick() {\n    inputRef.current.focus()\n  }\n\n  return (\n    <>\n      <MyInput ref={inputRef} />\n      <button type=\"button\" onClick={handleClick}>Focus the input</button>\n    </>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usecontext-hook",children:"UseContext Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Create custom ",(0,r.jsx)(n.code,{children:"XXXContextProvider"}),":\n\u4e00\u822c\u90fd\u4e0d\u4f1a\u88f8\u9732\u5730\u4f7f\u7528 Context.Provider, \u800c\u662f\u5c01\u88c5\u4e3a\u72ec\u7acb\u7684 Provider \u7ec4\u4ef6,\n\u5c06\u5b50\u7ec4\u4ef6\u4f5c\u4e3a props.children \u4f20\u5165, \u8fd9\u6837\u5f53 Context \u53d8\u5316\u65f6 Provider \u4e0d\u4f1a\u91cd\u65b0\u6e32\u67d3\u5b83\u7684\u5b50\u7ec4\u4ef6,\n\u7531\u4f9d\u8d56\u4e86 context \u7684\u5b50\u7ec4\u4ef6\u81ea\u5df1\u8fdb\u884c\u91cd\u6e32\u67d3, \u672a\u4f9d\u8d56\u7684\u5b50\u7ec4\u4ef6\u4e0d\u4f1a\u91cd\u65b0\u6e32\u67d3.\n",(0,r.jsxs)(n.strong,{children:["\u4f7f\u7528 ",(0,r.jsx)(n.code,{children:"useMemo"})," \u4f7f\u5f97 value \u4e0d\u4f1a\u5bfc\u81f4\u4e0d\u5fc5\u8981\u7684\u91cd\u590d\u6e32\u67d3 (Re-rendering)"]}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Create custom ",(0,r.jsx)(n.code,{children:"useXXXContext"})," hook:"]}),"\n",(0,r.jsxs)(n.li,{children:["Check whether component under ",(0,r.jsx)(n.code,{children:"XXXContextProvider"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Wrap complex context logic and only expose simple API (Facade design pattern)."}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"useMemo"}),"/",(0,r.jsx)(n.code,{children:"useCallback"})," to ",(0,r.jsx)(n.strong,{children:"memorize values and functions"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Context \u4e2d\u53ea\u5b9a\u4e49\u88ab\u5927\u591a\u6570\u7ec4\u4ef6\u6240\u5171\u7528\u7684\u5c5e\u6027,\nuse context to avoid ",(0,r.jsx)(n.strong,{children:"Prop Drilling"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usecontext-hooks-dispatcher",children:"UseContext Hooks Dispatcher"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HooksDispatcherOnMount.useContext = readContext"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HooksDispatcherOnUpdate.useContext = readContext"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HooksDispatcherOnRerender.useContext = readContext"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function createContext<T>(\n  defaultValue: T,\n  calculateChangedBits: ?((a: T, b: T) => number)\n): ReactContext<T> {\n  if (calculateChangedBits === undefined)\n    calculateChangedBits = null\n\n  const context: ReactContext<T> = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null,\n  }\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context,\n  }\n  context.Consumer = context\n  return context\n}\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n): Fiber | null {\n  const updateLanes = workInProgress.lanes\n  workInProgress.lanes = NoLanes\n\n  switch (workInProgress.tag) {\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes)\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes)\n  }\n}\n\nfunction updateContextProvider(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n) {\n  const providerType: ReactProviderType<any> = workInProgress.type\n  const context: ReactContext<any> = providerType._context\n\n  const newProps = workInProgress.pendingProps\n  const oldProps = workInProgress.memoizedProps\n  const newValue = newProps.value // <Provider value={}>{children}</Provider>\n\n  // \u66f4\u65b0 ContextProvider._currentValue:\n  // workInProgress.type._context._currentValue = newValue;\n  pushProvider(workInProgress, newValue)\n\n  if (oldProps !== null) {\n    // \u66f4\u65b0\u9636\u6bb5.\n    // \u5bf9\u6bd4 newValue \u548c oldValue\n    const oldValue = oldProps.value\n    const changedBits = calculateChangedBits(context, newValue, oldValue)\n\n    if (changedBits === 0) {\n      // value \u6ca1\u6709\u53d8\u52a8, \u8fdb\u5165 Bailout \u903b\u8f91.\n      if (\n        oldProps.children === newProps.children\n        && !hasLegacyContextChanged()\n      ) {\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes\n        )\n      }\n    } else {\n      // value\u53d8\u52a8, \u67e5\u627e\u5bf9\u5e94\u7684 Consumers, \u5e76\u4f7f\u5176\u80fd\u591f\u88ab\u66f4\u65b0.\n      // \u5411\u4e0b\u904d\u5386:\n      // \u4ece ContextProvider \u8282\u70b9\u5f00\u59cb,\n      // \u5411\u4e0b\u67e5\u627e\u6240\u6709 fiber.dependencies \u4f9d\u8d56\u8be5 context \u7684\u8282\u70b9.\n      // \u5411\u4e0a\u904d\u5386:\n      // \u4ece ContextConsumer \u8282\u70b9\u5f00\u59cb,\n      // \u5411\u4e0a\u904d\u5386, \u4fee\u6539\u7236\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684 fiber.childLanes \u5c5e\u6027, \u8868\u660e\u5176\u5b50\u8282\u70b9\u6709\u6539\u52a8, \u5b50\u8282\u70b9\u4f1a\u8fdb\u5165\u66f4\u65b0\u903b\u8f91.\n      propagateContextChange(workInProgress, context, changedBits, renderLanes)\n    }\n  }\n\n  // \u751f\u6210\u4e0b\u7ea7 Fiber.\n  const newChildren = newProps.children\n  reconcileChildren(current, workInProgress, newChildren, renderLanes)\n  return workInProgress.child\n}\n\nfunction updateContextConsumer(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n) {\n  const context: ReactContext<any> = workInProgress.type\n  const newProps = workInProgress.pendingProps\n  const render = newProps.children\n\n  // \u8bfb\u53d6 context.\n  prepareToReadContext(workInProgress, renderLanes)\n  const newValue = readContext(context, newProps.unstable_observedBits)\n\n  // \u751f\u6210\u4e0b\u7ea7 Fiber.\n  const newChildren = render(newValue)\n  reconcileChildren(current, workInProgress, newChildren, renderLanes)\n  return workInProgress.child\n}\n\nfunction prepareToReadContext(workInProgress: Fiber, renderLanes: Lanes): void {\n  // Setup.\n  currentlyRenderingFiber = workInProgress\n  lastContextDependency = null\n  lastContextWithAllBitsObserved = null\n  const dependencies = workInProgress.dependencies\n\n  if (dependencies !== null) {\n    const firstContext = dependencies.firstContext\n\n    if (firstContext !== null) {\n      if (includesSomeLane(dependencies.lanes, renderLanes)) {\n        // Context list has a pending update.\n        // Mark that this fiber performed work.\n        markWorkInProgressReceivedUpdate()\n      }\n\n      // Reset the work-in-progress list\n      dependencies.firstContext = null\n    }\n  }\n}\n\nfunction readContext<T>(\n  context: ReactContext<T>,\n  observedBits: void | number | boolean\n): T {\n  const contextItem = {\n    context: context as ReactContext<mixed>,\n    observedBits: resolvedObservedBits,\n    next: null,\n  }\n\n  // 1. \u6784\u9020\u4e00\u4e2a contextItem, \u52a0\u5165\u5230 workInProgress.dependencies \u94fe\u8868.\n  if (lastContextDependency === null) {\n    lastContextDependency = contextItem\n    currentlyRenderingFiber.dependencies = {\n      lanes: NoLanes,\n      firstContext: contextItem,\n      responders: null,\n    }\n  } else {\n    lastContextDependency = lastContextDependency.next = contextItem\n  }\n\n  // 2. \u8fd4\u56de currentValue.\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usecontext-hooks-usage",children:"UseContext Hooks Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n} from 'react'\n\nconst CountContext = createContext()\n\nexport default function CountProvider(props) {\n  const [count, setCount] = useState(0)\n\n  // Use `useMemo`/`useCallback` to memorize values and functions.\n  const value = useMemo(() => {\n    return {\n      count,\n      setCount,\n    }\n  }, [count, setCount])\n\n  return <CountContext value={value} {...props} />\n}\n\nfunction useCount() {\n  const context = useContext(CountContext)\n\n  // Check whether component under `XXXContextProvider`.\n  if (!context)\n    throw new Error('useCount must be used within a CountProvider')\n\n  // Wrap complex context logic, only expose simple API.\n  const { count, setCount } = context\n  const increment = useCallback(() => setCount(c => c + 1), [setCount])\n\n  return {\n    count,\n    increment,\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"useeffect-hook",children:"UseEffect Hook"}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-hooks-dispatcher",children:"UseEffect Hooks Dispatcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null\n): void {\n  return mountEffectImpl(\n    UpdateEffect | PassiveEffect,\n    HookPassive,\n    create,\n    deps\n  )\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = mountWorkInProgressHook()\n  const nextDeps = deps === undefined ? null : deps\n  currentlyRenderingFiber.flags |= fiberFlags // UpdateEffect | PassiveEffect.\n  hook.memoizedState = pushEffect(\n    HasEffect | hookFlags, // PassiveHook.\n    create,\n    undefined,\n    nextDeps\n  )\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null\n): void {\n  return updateEffectImpl(PassiveEffect, HookPassive, create, deps)\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = updateWorkInProgressHook()\n  const nextDeps = deps === undefined ? null : deps\n  let destroy\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState\n    destroy = prevEffect.destroy\n\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        // \u5982\u679c\u4f9d\u8d56\u4e0d\u53d8, \u65b0\u5efa Effect (tag \u4e0d\u542b HookHasEffect).\n        // Reconciler.Commit \u9636\u6bb5\u4f1a\u8df3\u8fc7\u6b64 Effect.\n        pushEffect(hookFlags, create, destroy, nextDeps)\n        return\n      }\n    }\n  }\n\n  // \u5982\u679c\u4f9d\u8d56\u6539\u53d8, \u66f4\u6539 fiber.flags, \u65b0\u5efa Effect.\n  // Reconciler.Commit \u9636\u6bb5\u4f1a\u518d\u6b21\u6267\u884c\u6b64 Effect.\n  currentlyRenderingFiber.flags |= fiberFlags\n  hook.memoizedState = pushEffect(\n    HasEffect | hookFlags,\n    create,\n    destroy,\n    nextDeps\n  )\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create, // User code: effect callback.\n    destroy, // User code: destroy callback.\n    deps, // User code: deps list.\n    next: null,\n  }\n\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue()\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue\n    componentUpdateQueue.lastEffect = effect.next = effect\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect\n    } else {\n      // Circular effect list.\n      const firstEffect = lastEffect.next\n      lastEffect.next = effect\n      effect.next = firstEffect\n      componentUpdateQueue.lastEffect = effect\n    }\n  }\n\n  return effect\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-lifecycle",children:"UseEffect Lifecycle"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"React renders UI for current props/state to screen."}),"\n",(0,r.jsx)(n.li,{children:"React cleans up the effect for prev props/state."}),"\n",(0,r.jsxs)(n.li,{children:["React runs the effect for current props/state\n(",(0,r.jsx)(n.code,{children:"useEffect"})," got invoked after ",(0,r.jsx)(n.code,{children:"componentDidMount"}),")."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-nasty-loop",children:"UseEffect Nasty Loop"}),"\n",(0,r.jsxs)(n.p,{children:["The effect hook runs when the component ",(0,r.jsx)(n.code,{children:"mounts"}),"\nbut also when the component ",(0,r.jsx)(n.code,{children:"updates"}),".\nBecause we are setting the state after every data fetch,\nthe component updates and the effect runs again.\nIt fetches the data again and again.\nThat\u2019s a bug and needs to be avoided."]}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-deps-list",children:"UseEffect Deps List"}),"\n",(0,r.jsxs)(n.p,{children:["\u65e0\u8bba\u662f\u5c06\u7ec4\u4ef6\u7f16\u5199\u4e3a\u7c7b\u8fd8\u662f\u51fd\u6570,\n\u90fd\u5fc5\u987b\u4e3a effect \u54cd\u5e94\u6240\u6709 props \u548c state \u7684\u66f4\u65b0\n(",(0,r.jsx)(n.code,{children:"Reactive Value"}),").\n\u5728\u4f20\u7edf\u7684 Class Component, \u9700\u8981\u7f16\u5199\u4ee3\u7801\u53bb\u68c0\u6d4b\u8fd9\u4e9b props \u548c state \u662f\u5426\u53d8\u66f4\n(",(0,r.jsx)(n.code,{children:"shouldComponentUpdate"}),", ",(0,r.jsx)(n.code,{children:"componentDidUpdate"}),").\n\u5728 Function Component, \u501f\u52a9 ",(0,r.jsx)(n.code,{children:"useEffect"})," \u53ef\u4ee5\u5b9e\u73b0\u81ea\u52a8\u68c0\u6d4b."]}),"\n",(0,r.jsxs)(n.p,{children:["If one of deps list changes, the hook runs again.\nProvide ",(0,r.jsx)(n.strong,{children:"empty array"})," as second argument to the effect hook\nto avoid activating it on component updates\nbut ",(0,r.jsx)(n.strong,{children:"only for the mounting"})," of the component.\nFor listeners binding, use ",(0,r.jsx)(n.code,{children:"[]"})," deps list should be better."]}),"\n",(0,r.jsx)(n.h4,{id:"useeffect-omit-deps",children:"UseEffect Omit Deps"}),"\n",(0,r.jsx)(n.p,{children:"Omit stable values from the deps list:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"set"})," function returned from ",(0,r.jsx)(n.code,{children:"useState"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ref"})," object returned from ",(0,r.jsx)(n.code,{children:"useRef"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function App() {\n  const [count, setCount] = useState(0)\n  const countRef = useRef(count)\n\n  useEffect(() => {\n    countRef.current = count\n  }, [count]) // \u2705 Only count is declared.\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"useeffect-primitive-deps",children:"UseEffect Primitive Deps"}),"\n",(0,r.jsxs)(n.p,{children:["Primitive values are ",(0,r.jsx)(n.a,{href:"https://react.dev/learn/removing-effect-dependencies",children:"better"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function ChatRoom({ options }) {\n  const [message, setMessage] = useState('')\n  const { roomId, serverUrl } = options\n\n  useEffect(() => {\n    const connection = createConnection({\n      roomId,\n      serverUrl,\n    })\n    connection.connect()\n    return () => connection.disconnect()\n  }, [roomId, serverUrl]) // \u2705 All dependencies declared\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"useeffect-functions-deps",children:"UseEffect Functions Deps"}),"\n",(0,r.jsxs)(n.p,{children:["Functions in ",(0,r.jsx)(n.code,{children:"useEffect"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If only use some functions inside an effect, move them directly into that effect."}),"\n",(0,r.jsx)(n.li,{children:"Hoisting functions that don\u2019t need props or state outside of component,\nand pull the ones that are used only by an effect inside of that effect."}),"\n",(0,r.jsxs)(n.li,{children:["For useCallback function, it should be in deps list ",(0,r.jsx)(n.code,{children:"useEffect(() => {}, [callback])"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios'\n// https://www.robinwieruch.de/react-hooks-fetch-data\nimport { useEffect, useState } from 'react'\n\nfunction useDataApi(initialUrl, initialData) {\n  const [data, setData] = useState(initialData)\n  const [url, setUrl] = useState(initialUrl)\n  const [isLoading, setIsLoading] = useState(false)\n  const [isError, setIsError] = useState(false)\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setIsError(false)\n      setIsLoading(true)\n\n      try {\n        const result = await axios(url)\n\n        setData(result.data)\n      } catch (error) {\n        setIsError(true)\n      }\n\n      setIsLoading(false)\n    }\n\n    fetchData()\n  }, [url])\n\n  const doFetch = (url) => {\n    setUrl(url)\n  }\n\n  return { data, isLoading, isError, doFetch }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"useeffect-compare-deps",children:"UseEffect Compare Deps"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { DependencyList, EffectCallback, useEffect, useRef } from 'react'\n\nconst isPrimitive = (val: any) => val !== Object(val)\n\ntype DepsEqualFnType<TDeps extends DependencyList>\n  = (prevDeps: TDeps, nextDeps: TDeps) => boolean\n\nexport default function useCustomCompareEffect<TDeps extends DependencyList>(\n  effect: EffectCallback,\n  deps: TDeps,\n  depsEqual: DepsEqualFnType<TDeps>,\n) {\n  const ref = useRef<TDeps | undefined>(undefined)\n\n  if (!ref.current || !depsEqual(deps, ref.current))\n    ref.current = deps\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(effect, ref.current)\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { DependencyList, EffectCallback } from 'react'\nimport fastDeepEqual from './misc/fastDeepEqual'\nimport useCustomCompareEffect from './useCustomCompareEffect'\n\nconst isPrimitive = (val: any) => val !== Object(val)\n\nexport default function useDeepCompareEffect(\n  effect: EffectCallback,\n  deps: DependencyList,\n) {\n  useCustomCompareEffect(effect, deps, fastDeepEqual)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-closure",children:"UseEffect Closure"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"useEffect Hook \u4f1a\u4e22\u5f03\u4e0a\u4e00\u6b21\u6e32\u67d3\u7ed3\u679c,\n\u5b83\u4f1a\u6e05\u9664\u4e0a\u4e00\u6b21 effect,\n\u518d\u5efa\u7acb\u4e0b\u4e00\u4e2a effect\n(\u4e5f\u4f1a\u521b\u5efa\u65b0\u7684 Closure),\n\u4e0b\u4e00\u4e2a effect \u9501\u4f4f\u65b0\u7684 props \u548c state\n(\u6574\u4e2a Counter \u51fd\u6570\u5728 re-render \u65f6\u4f1a\u88ab\u91cd\u590d\u8c03\u7528\u4e00\u6b21)."}),"\n",(0,r.jsx)(n.li,{children:"setInterval \u4e0d\u4f1a\u4e22\u5f03\u4e0a\u4e00\u6b21\u7ed3\u679c,\n\u4f1a\u5f15\u7528\u65e7\u72b6\u6001 Closure \u4e2d\u7684\u53d8\u91cf,\n\u5bfc\u81f4\u5176\u4e0e useEffect \u6240\u9884\u671f\u884c\u4e3a\u4e0d\u4e00\u81f4."}),"\n",(0,r.jsx)(n.li,{children:"\u53ef\u4ee5\u901a\u8fc7 useRef \u89e3\u51b3\u8fd9\u4e00\u73b0\u8c61: get latest value."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// BUG\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1) // always 1 regardless `count` value change\n    }, 1000)\n    return () => clearInterval(id)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  return <h1>{count}</h1>\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Counter() {\n  const [count, setCount] = useState(0)\n\n  useInterval(() => {\n    setCount(count + 1)\n  }, 1000)\n\n  return <h1>{count}</h1>\n}\n\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef(callback)\n\n  // Remember the latest callback if it changes\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  // Set up the interval\n  useEffect(() => {\n    function tick() {\n      savedCallback.current()\n    }\n\n    const id = setInterval(tick, delay)\n    return () => clearInterval(id)\n  }, [delay])\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-state",children:"UseEffect State"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u5982 ",(0,r.jsx)(n.code,{children:"UseEffect Closure"})," \u6240\u8ff0, \u6bcf\u6b21\u8c03\u7528 useEffect \u65f6,\n\u4f1a\u6355\u83b7\u90a3\u4e00\u6b21 render \u65f6\u7684 props \u548c state."]}),"\n",(0,r.jsx)(n.li,{children:"Class Component \u4e2d\u7684 this.state.xxx \u5374\u603b\u662f\u6307\u5411\u6700\u65b0\u7684 state."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Counter() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(`You clicked ${count} times`)\n    }, 3000)\n  })\n\n  return (\n    <div>\n      <p>\n        You clicked\n        {' '}\n        {count}\n        {' '}\n        times\n      </p>\n      <button type=\"button\" onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n// Output:\n// Mounted: You clicked 0 times\n// Clicked 5 times in 3s\n// You clicked 1 times\n// You clicked 2 times\n// You clicked 3 times\n// You clicked 4 times\n// You clicked 5 times\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"class Counter {\n  componentDidUpdate() {\n    setTimeout(() => {\n      console.log(`You clicked ${this.state.count} times`)\n    }, 3000)\n  }\n\n  render() {\n    const { count } = this.props\n\n    return (\n      <div>\n        <p>\n          You clicked\n          {' '}\n          {count}\n          {' '}\n          times\n        </p>\n        <button type=\"button\" onClick={() => this.setState(count + 1)}>Click me</button>\n      </div>\n    )\n  }\n}\n// Output:\n// Mounted: You clicked 0 times\n// Clicked 5 times in 3s\n// You clicked 5 times\n// You clicked 5 times\n// You clicked 5 times\n// You clicked 5 times\n// You clicked 5 times\n"})}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-cleanup",children:"UseEffect Cleanup"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Avoid memory leaks."}),"\n",(0,r.jsx)(n.li,{children:"Prevent unexpected errors."}),"\n",(0,r.jsx)(n.li,{children:"Good user experience."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Cleanup API requests (",(0,r.jsx)(n.a,{href:"https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect",children:"race condition"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Boolean"})," flag."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AbortController"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function App({ url }) {\n  const [results, setResults] = useState([])\n  const [page, setPage] = useState(1)\n\n  // Cleanup with Boolean flag:\n  useEffect(() => {\n    let ignore = false\n    fetchResults(url, page).then((json) => {\n      if (!ignore)\n        setResults(json)\n    })\n    return () => {\n      ignore = true\n    }\n  }, [url, page])\n\n  // Cleanup with AbortController:\n  useEffect(() => {\n    const controller = new AbortController()\n    const { signal } = controller\n\n    const fetchData = async () => {\n      const response = await fetch(url, { signal })\n      const json = await response.json()\n      setResults(json)\n    }\n\n    fetchData()\n\n    return () => controller.abort()\n  }, [url])\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Cleanup connections:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function App() {\n  useEffect(() => {\n    const socket = new WebSocket('url', protocols)\n    // do what you want with the socket\n\n    return () => socket.close()\n  }, [])\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Cleanup timeouts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function App() {\n  useEffect(() => {\n    const timeoutId = setTimeout(() => {\n      // do something in the timeout\n    }, 3000)\n\n    return () => clearTimeout(timeoutId)\n  }, [])\n}\n"})}),"\n",(0,r.jsxs)(n.admonition,{title:"React 18 Development Strict Mode",type:"caution",children:[(0,r.jsxs)(n.p,{children:["With ",(0,r.jsx)(n.code,{children:"Strict Mode"})," in React 18,\nReact will simulate unmounting and remounting component in development mode:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["React mounts component:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Layout effects are created."}),"\n",(0,r.jsx)(n.li,{children:"Effect effects are created."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["React simulates unmounting component:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Layout effects are destroyed."}),"\n",(0,r.jsx)(n.li,{children:"Effects are destroyed."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["React simulates mounting component with previous state:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Layout effect setup code runs."}),"\n",(0,r.jsx)(n.li,{children:"Effect setup code runs."}),"\n"]}),"\n"]}),"\n"]}),(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"Strict Mode"})," is on,\nremounts twice helps find out ",(0,r.jsx)(n.code,{children:"Effects"})," need cleanup\nand exposes bugs like race conditions early."]})]}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-usage",children:"UseEffect Usage"}),"\n",(0,r.jsxs)(n.p,{children:["Effects are typically used to\n",(0,r.jsx)(n.a,{href:"https://react.dev/learn/synchronizing-with-effects",children:"synchronize with external system"}),":\nbrowser APIs,\nthird-party library,\nnetwork, and so on."]}),"\n",(0,r.jsx)(n.p,{children:"Effects let you specify side effects that are caused by rendering itself,\nrather than by a particular event:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Sending a message in the chat is an event\nbecause it is directly caused by user clicking a specific button:\nput it in ",(0,r.jsx)(n.code,{children:"handleClick()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["However, setting up a server connection is an ",(0,r.jsx)(n.code,{children:"Effect"}),"\nbecause it needs to happen regardless of\nwhich interaction caused the component to appear:\nput int in ",(0,r.jsx)(n.code,{children:"useEffect()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If your effect only adjusts some state based on other state,\n",(0,r.jsx)(n.a,{href:"https://react.dev/learn/you-might-not-need-an-effect",children:"you might not need effects"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You don\u2019t need Effects to transform data for rendering."}),"\n",(0,r.jsx)(n.li,{children:"You don\u2019t need Effects to handle user events."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function handleClick() {\n  // \u2705 Buying is an event because it is caused by a particular interaction.\n  fetch('/api/buy', { method: 'POST' })\n  showNotification(`Added ${product.name} to the shopping cart!`)\n  navigateTo('/checkout')\n}\n\nfunction Form() {\n  const [firstName, setFirstName] = useState('')\n  const [lastName, setLastName] = useState('')\n\n  // \u2705 Good: calculated during rendering\n  const fullName = `${firstName} ${lastName}`\n\n  // \u2705 Good: This logic runs because the component was displayed\n  useEffect(() => {\n    post('/analytics/event', { eventName: 'visit_form' })\n  }, [])\n\n  function handleSubmit(e) {\n    e.preventDefault()\n    // \u2705 Good: Event-specific logic is in the event handler\n    post('/api/register', { firstName, lastName })\n  }\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"useeffect-reference",children:"UseEffect Reference"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," complete ",(0,r.jsx)(n.a,{href:"https://overreacted.io/a-complete-guide-to-useeffect",children:"guide"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," usage ",(0,r.jsx)(n.a,{href:"https://react.dev/learn/you-might-not-need-an-effect",children:"guide"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"uselayouteffect-hook",children:"UseLayoutEffect Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useLayoutEffect"})," callback called ",(0,r.jsx)(n.strong,{children:"synchronously"}),"\n(fires synchronously after all DOM mutations),\nsubstitute for ",(0,r.jsx)(n.code,{children:"componentDidMount"})," lifecycle function:\n",(0,r.jsx)(n.code,{children:"Update"})," effect flags, ",(0,r.jsx)(n.code,{children:"HasEffect | Layout"})," hook flags."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," got invoked after ",(0,r.jsx)(n.code,{children:"componentDidMount"})," ",(0,r.jsx)(n.strong,{children:"asynchronously"}),":\n",(0,r.jsx)(n.code,{children:"Update | Passive"})," effect flags, ",(0,r.jsx)(n.code,{children:"HasEffect | Passive"})," hook flags."]}),"\n",(0,r.jsxs)(n.li,{children:["Lifecycle of React component:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"User interacts, props or state change."}),"\n",(0,r.jsx)(n.li,{children:"React updates DOM."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useLayoutEffect"})," hook fires."]}),"\n",(0,r.jsx)(n.li,{children:"Browser paints: visual changes are displayed to user."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," hook fires."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["If need to mutate DOM directly (visual changes to UI)\nor need to perform DOM measurements,\n",(0,r.jsx)(n.code,{children:"useLayoutEffect"})," is better than ",(0,r.jsx)(n.code,{children:"useEffect"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null\n): void {\n  return mountEffectImpl(\n    UpdateEffect, // Fiber Flags\n    HookLayout, // Hook Flags\n    create,\n    deps\n  )\n}\n\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null\n): void {\n  return mountEffectImpl(\n    UpdateEffect | PassiveEffect, // Fiber Flags\n    HookPassive, // Hook Flags\n    create,\n    deps\n  )\n}\n\nfunction updateLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null\n): void {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps)\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null\n): void {\n  return updateEffectImpl(PassiveEffect, HookPassive, create, deps)\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"useinsertioneffect-hook",children:"UseInsertionEffect Hook"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/reactwg/react-18/discussions/110",children:(0,r.jsx)(n.code,{children:"useInsertionEffect"})}),"\nallows ",(0,r.jsx)(n.code,{children:"CSS-in-JS"})," libraries to address performance\nissues of injecting styles in render:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useInsertionEffect"})," will run after the DOM is mutated,\nbut before layout effects read the new layout."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function useCSS(rule) {\n  if (!canUseDOM)\n    collectedRulesSet.add(rule)\n\n  useInsertionEffect(() => {\n    if (!isInserted.has(rule)) {\n      isInserted.add(rule)\n      document.head.appendChild(getStyleForRule(rule))\n    }\n  })\n\n  return rule\n}\n\nexport default function Component() {\n  const className = useCSS(rule)\n  return <div className={className} />\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"useimperativehandle-hook",children:"UseImperativeHandle Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"interface MyInputHandles {\n  focus: () => void\n}\n\nconst MyInput: RefForwardingComponent<MyInputHandles, MyInputProps> = (\n  props,\n  ref\n) => {\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      if (inputRef.current)\n        inputRef.current.focus()\n    },\n  }))\n\n  return <input {...props} ref={inputRef} />\n}\n\nconst ForwardMyInput = React.forwardReft(MyInput)\nexport default ForwardMyInput\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usedebugvalue-hook",children:"UseDebugValue Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function App() {\n  const date = new Date()\n  useDebugValue(date, date => date.toISOString())\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usedeferredvalue-hook",children:"UseDeferredValue Hook"}),"\n",(0,r.jsx)(n.p,{children:"Debounce:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useDeferredValue } from 'react'\n\nexport default function App() {\n  const [text, setText] = useState('hello')\n\n  // Debounced value.\n  const deferredText = useDeferredValue(text, { timeoutMs: 2000 })\n\n  return (\n    <div>\n      <input value={text} onChange={handleChange} />\n      <List text={deferredText} />\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useDeferredValue"})," only works when ",(0,r.jsx)(n.code,{children:"SlowComponent"})," has been wrapped with ",(0,r.jsx)(n.code,{children:"React.memo()"}),".\nWithout ",(0,r.jsx)(n.code,{children:"React.memo()"}),",\n",(0,r.jsx)(n.code,{children:"SlowComponent"})," would re-render whenever its parent component re-renders,\nregardless of whether props has changed or not."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useDeferredValue, useState } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(0)\n  const deferredCount = useDeferredValue(count)\n  const isBusyRecalculating = count !== deferredCount\n\n  return (\n    <>\n      <ImportantStuff count={count} />\n      <SlowWrapper\n        style={{ opacity: isBusyRecalculating ? 0.5 : 1 }}\n      >\n        <SlowStuff count={deferredCount} />\n        {isBusyRecalculating && <Spinner />}\n      </SlowWrapper>\n      <button type=\"button\" onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usetransition-hook",children:"UseTransition Hook"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"startTransition"})," \u56de\u8c03\u4e2d\u7684\u66f4\u65b0\u90fd\u4f1a\u88ab\u8ba4\u4e3a\u662f",(0,r.jsx)(n.strong,{children:"\u975e\u7d27\u6025\u5904\u7406"}),",\n\u5982\u679c\u51fa\u73b0\u66f4\u7d27\u6025\u7684\u66f4\u65b0 (User Input), \u5219\u4e0a\u9762\u7684\u66f4\u65b0\u90fd\u4f1a\u88ab\u4e2d\u65ad,\n\u76f4\u5230\u6ca1\u6709\u5176\u4ed6\u7d27\u6025\u64cd\u4f5c\u4e4b\u540e\u624d\u4f1a\u53bb\u7ee7\u7eed\u6267\u884c\u66f4\u65b0."]}),"\n",(0,r.jsx)(n.p,{children:"Opt-in concurrent features (implementing debounce-like function):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useRef, useState, useTransition } from 'react'\nimport Spinner from './Spinner'\n\nexport default function App() {\n  const input = useRef('')\n  const [searchInputValue, setSearchInputValue] = useState('')\n  const [searchQuery, setSearchQuery] = useState('')\n  const [isPending, startTransition] = useTransition()\n\n  // Urgent: show what was typed.\n  setSearchInputValue(input)\n\n  // Debounced callback.\n  startTransition(() => {\n    setSearchQuery(input)\n  })\n\n  return <div>{isPending && <Spinner />}</div>\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"useid-hook",children:"UseId Hook"}),"\n",(0,r.jsx)(n.p,{children:"Generating unique IDs on client and server\n(\u6bcf\u4e2a ID \u4ee3\u8868\u8be5\u7ec4\u4ef6\u5728\u7ec4\u4ef6\u6811\u4e2d\u7684\u5c42\u7ea7\u7ed3\u6784):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'export default function Checkbox() {\n  const id = useId()\n\n  return (\n    <>\n      <label htmlFor={id}>Do you like React?</label>\n      <input type="checkbox" name="react" id={id} />\n    </>\n  )\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"usesyncexternalstore-hook",children:"UseSyncExternalStore Hook"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Props"}),"/",(0,r.jsx)(n.code,{children:"Context"}),"/",(0,r.jsx)(n.code,{children:"useState"}),"/",(0,r.jsx)(n.code,{children:"useReducer"})," are internal states\nnot affected by concurrent features."]}),"\n",(0,r.jsx)(n.p,{children:"External stores affected by concurrent features including:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Global variables: ",(0,r.jsx)(n.code,{children:"document.body"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Date."}),"\n",(0,r.jsx)(n.li,{children:"Redux store."}),"\n",(0,r.jsx)(n.li,{children:"Zustand store."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useSyncExternalStore"})," allows external stores to support concurrent reads\nby forcing updates to the store to be synchronous:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Caching data from external APIs:\nAs this hook is mostly used to subscribe external third-party data sources,\ncaching that data gets simpler as well.\nYou can keep your app's data in sync with the external data source\nand later can also use it for offline support."}),"\n",(0,r.jsx)(n.li,{children:'WebSocket connection:\nAs a WebSocket is a "continuous" connection,\nyou can use this hook to manage the WebSocket connection state data in real-time.'}),"\n",(0,r.jsxs)(n.li,{children:["Managing browser storage:\nIn such cases where you need to sync data\nbetween the web browser's storage and the application's state,\nyou can use ",(0,r.jsx)(n.code,{children:"useSyncExternalStore"})," to subscribe to updates in the external store."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type UseSyncExternalStore = <State>(\n  subscribe: (callback: Callback) => Unsubscribe,\n  getSnapshot: () => State,\n  getServerSnapshot?: () => State,\n) => State\n\nexport function useSyncExternalStore<Snapshot>(\n  subscribe: (onStoreChange: () => void) => () => void,\n  getSnapshot: () => Snapshot,\n  getServerSnapshot?: () => Snapshot,\n): Snapshot\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"subscribe"})," method should subscribe to store changes,\nand it should return function to unsubscribe from store changes.\nEnsure ",(0,r.jsx)(n.code,{children:"onStoreChange"})," is called whenever store changes,\nwill trigger re-render of component."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getSnapshot"})," method would return a snapshot of data from store.\nWhile store has not changed, repeated calls to getSnapshot must return same value.\nIf store changes and returned value is different (as compared by Object.is),\nReact re-renders component."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getServerSnapshot"})," method would return ",(0,r.jsx)(n.strong,{children:"initial"})," snapshot of data from server.\nIt will be used only during server rendering\nand during hydration of server-rendered content on client.\nThe server snapshot must be the same between client and server,\nand is usually serialized and passed from server to client."]}),"\n",(0,r.jsx)(n.h3,{id:"sync-browser-api",children:"Sync Browser API"}),"\n",(0,r.jsxs)(n.p,{children:["Sync navigator ",(0,r.jsx)(n.code,{children:"online"})," API:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function subscribe(onStoreChange) {\n  window.addEventListener('online', onStoreChange)\n  window.addEventListener('offline', onStoreChange)\n  return () => {\n    window.removeEventListener('online', onStoreChange)\n    window.removeEventListener('offline', onStoreChange)\n  }\n}\n\nfunction useOnlineStatus() {\n  return useSyncExternalStore(\n    subscribe,\n    () => navigator.onLine,\n    () => true\n  )\n}\n\nfunction ChatIndicator() {\n  const isOnline = useOnlineStatus()\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sync-browser-event",children:"Sync Browser Event"}),"\n",(0,r.jsxs)(n.p,{children:["Sync browser ",(0,r.jsx)(n.code,{children:"scroll"})," event:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// A memoized constant fn prevents unsubscribe/resubscribe\n// In practice it is not a big deal\nfunction subscribe(onStoreChange) {\n  globalThis.window?.addEventListener('scroll', onStoreChange)\n  return () => globalThis.window?.removeEventListener('scroll', onStoreChange)\n}\n\nfunction useScrollY(selector = id => id) {\n  return useSyncExternalStore(\n    subscribe,\n    () => selector(globalThis.window?.scrollY),\n    () => undefined\n  )\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function ScrollY() {\n  const scrollY = useScrollY()\n  return <div>{scrollY}</div>\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function ScrollYFloored() {\n  const to = 100\n  const scrollYFloored = useScrollY(y =>\n    y ? Math.floor(y / to) * to : undefined\n  )\n  return <div>{scrollYFloored}</div>\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sync-browser-router",children:"Sync Browser Router"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function useHistorySelector(selector) {\n  const history = useHistory()\n  return useSyncExternalStore(history.listen, () => selector(history))\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function CurrentPathname() {\n  const pathname = useHistorySelector(history => history.location.pathname)\n  return <div>{pathname}</div>\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function CurrentHash() {\n  const hash = useHistorySelector(history => history.location.hash)\n  return <div>{hash}</div>\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sync-external-state",children:"Sync External State"}),"\n",(0,r.jsxs)(n.p,{children:["Simple demo from ",(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=oPfSC5bQPR8",children:"React Conf 2021"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useSyncExternalStore } from 'react'\n\n// We will also publish a backwards compatible shim\n// It will prefer the native API, when available\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nconst store = {\n  state: { count: 0 },\n  listeners: new Set(),\n  setState: (fn) => {\n    store.state = fn(store.state)\n    store.listeners.forEach(listener => listener())\n  },\n  subscribe: (callback) => {\n    store.listeners.add(callback)\n    return () => store.listeners.delete(callback)\n  },\n  getSnapshot: () => {\n    const snap = Object.freeze(store.state)\n    return snap\n  },\n}\n\nexport default function App() {\n  // Basic usage. getSnapshot must return a cached/memoized result\n  const state = useSyncExternalStore(store.subscribe, store.getSnapshot)\n\n  // Selecting a specific field using an inline getSnapshot\n  const selectedField = useSyncExternalStore(\n    store.subscribe,\n    () => store.getSnapshot().count\n  )\n\n  return (\n    <div>\n      {state.count}\n      {selectedField}\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Migrate from ",(0,r.jsx)(n.code,{children:"useState"})," + ",(0,r.jsx)(n.code,{children:"useEffect"})," + ",(0,r.jsx)(n.code,{children:"useRef"})," to ",(0,r.jsx)(n.code,{children:"useSyncExternalStore"}),"\nfor 3rd external stores libraries (e.g ",(0,r.jsx)(n.code,{children:"Redux"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useCallback, useEffect, useState } from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nfunction createStore(initialState) {\n  let state = initialState\n  const listeners = new Set()\n\n  const getState = () => state\n  const setState = (fn) => {\n    state = fn(state)\n    listeners.forEach(listener => listener())\n  }\n  const subscribe = (listener) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }\n\n  return {\n    getState,\n    setState,\n    subscribe,\n  }\n}\n\n// Explicitly process external store for React v17.\n// Sync external store state to React internal state\n// with `useState` and `store.subscribe`:\n// store.setState -> updater -> setState.\nfunction useStoreLegacy(store, selector) {\n  const [state, setState] = useState(selector(store.getState()))\n\n  useEffect(() => {\n    const updater = () => setState(selector(store.getState()))\n    const unsubscribe = store.subscribe(updater)\n    updater()\n    return unsubscribe\n  }, [store, selector])\n\n  return state\n}\n\n// Use `useSyncExternalStore` for React v18+.\nfunction useStore(store, selector) {\n  return useSyncExternalStore(\n    store.subscribe,\n    useCallback(() => selector(store.getState()), [store, selector])\n  )\n}\n\nconst store = createStore({ count: 0, text: 'hello' })\n\nfunction Counter() {\n  const count = useStore(\n    store,\n    useCallback(state => state.count, [])\n  )\n\n  const handleClick = () =>\n    store.setState(state => ({ ...state, count: state.count + 1 }))\n\n  return (\n    <div>\n      {count}\n      <button type=\"button\" onClick={handleClick}>+1</button>\n    </div>\n  )\n}\n\nfunction TextBox() {\n  const text = useStore(\n    store,\n    useCallback(state => state.text, [])\n  )\n\n  const handleChange = (event) => {\n    store.setState(state => ({ ...state, text: event.target.value }))\n  }\n\n  return (\n    <div>\n      <input type=\"text\" value={text} onChange={handleChange} />\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <div>\n      <Counter />\n      <Counter />\n      <TextBox />\n      <TextBox />\n    </div>\n  )\n}\n\nReact.createRoot(document.querySelector('#root')).render(<App />)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"useevent-hook",children:"UseEvent Hook"}),"\n",(0,r.jsxs)(n.p,{children:["Extracting non-reactive logic out of ",(0,r.jsx)(n.code,{children:"useEffect"}),",\n",(0,r.jsxs)(n.a,{href:"https://react.dev/learn/separating-events-from-effects",children:["put them into ",(0,r.jsx)(n.code,{children:"useEvent"})]}),",\ncall ",(0,r.jsx)(n.code,{children:"useEvent"})," from inside ",(0,r.jsx)(n.code,{children:"useEffect"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useCallback, useEffect, useInsertionEffect, useRef } from 'react'\n\nfunction useEvent(fn) {\n  const ref = useRef(null)\n  useInsertionEffect(() => {\n    ref.current = fn\n  }, [fn])\n  return useCallback((...args) => {\n    const f = ref.current // Get latest snapshot, break out closure.\n    return f(...args)\n  }, [])\n}\n\nfunction ChatRoom({ roomId, theme }) {\n  const onConnected = useEvent((connectedRoomId) => {\n    // Non-reactive to `theme`.\n    showNotification(`Welcome to ${connectedRoomId}`, theme)\n  })\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId)\n    connection.on('connected', () => {\n      onConnected(roomId)\n    })\n    connection.connect()\n    return () => connection.disconnect()\n  }, [roomId, onConnected]) // Linter will allow [roomId] in the future.\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Event functions let you split an ",(0,r.jsx)(n.code,{children:"Effect"}),'\ninto reactive parts (which should "react" to reactive values and their changes)\nand non-reactive parts (which only read their latest values).']}),"\n",(0,r.jsx)(n.h2,{id:"useoptimistic-hook",children:"UseOptimistic Hook"}),"\n",(0,r.jsx)(n.h3,{id:"useoptimistic-hooks-dispatcher",children:"UseOptimistic Hooks Dispatcher"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://jser.dev/2024-03-20-how-does-useoptimisticwork-internally-in-react#42-updateoptimistic",children:(0,r.jsx)(n.code,{children:"updateOptimistic()"})}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An optimistic update has ",(0,r.jsx)(n.code,{children:"revertLane"})," of ",(0,r.jsx)(n.code,{children:"TransitionLaneXX"})," and ",(0,r.jsx)(n.code,{children:"lane"})," of ",(0,r.jsx)(n.code,{children:"SyncLane"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Update is processed in ",(0,r.jsx)(n.code,{children:"SyncLane"})," and also in all following renders,\nbut it is NOT skipped and always kept in the next update queue."]}),"\n",(0,r.jsxs)(n.li,{children:["Update is reverted in ",(0,r.jsx)(n.code,{children:"revertLane"})," (low priority transition lane),\nby NOT getting added to the next queue.\nBut if the async action on the transition lane is not yet complete,\nit suspends by throwing the promise.\nThe revert will be tried again after the async action is done."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"custom-hooks",children:"Custom Hooks"}),"\n",(0,r.jsx)(n.h3,{id:"custom-lifecycle-hooks",children:"Custom LifeCycle Hooks"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"componentDidMount"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function useMount(fn) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => fn(), [])\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"componentWillUnmount:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function useUnmount(fn) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => fn, [])\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"componentDidUpdate:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function useUpdate(effectCallback) {\n  const mounting = useRef(true)\n\n  useEffect(() => {\n    // First get called for componentDidMount lifecycle,\n    // so skip it.\n    if (mounting.current)\n      mounting.current = false\n    else\n      return effectCallback()\n  })\n}\n\nfunction useUpdateDeps(effectCallback, deps) {\n  const mounting = useRef(true)\n\n  React.useEffect(() => {\n    return () => {\n      mounting.current = true\n    }\n  }, [])\n\n  React.useEffect(() => {\n    // Do not execute effectCallback for the first time.\n    if (mounting.current)\n      mounting.current = false\n    else\n      return effectCallback()\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Force Update:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const useUpdate = () => useState(0)[1]\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useState } from 'react'\n\ninterface VoidFunction {\n  (): void\n}\n\ninterface VoidFunctionCreator {\n  (): VoidFunction\n}\n\nconst max = 9007199254740990 // Number.MAX_SAFE_INTEGER - 1;\n\nconst useForceUpdate: VoidFunctionCreator = (): VoidFunction => {\n  const [, setState] = useState(0)\n  const forceUpdate: VoidFunction = (): void => {\n    setState((state: number) => (state + 1) % max)\n  }\n  return forceUpdate\n}\n\nexport default useForceUpdate\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"isMounted"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function useIsMounted() {\n  const [isMount, setIsMount] = useState(false)\n\n  useEffect(() => {\n    if (!isMount)\n      setIsMount(true)\n\n    return () => setIsMount(false)\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  return isMount\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-previous-hook",children:"Custom Previous Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function Counter() {\n  const [count, setCount] = useState(0)\n  const prevCount = usePrevious(count)\n  return (\n    <h1>\n      Now:\n      {' '}\n      {count}\n      , before:\n      {' '}\n      {prevCount}\n    </h1>\n  )\n}\n\nfunction usePrevious(value) {\n  const ref = useRef()\n  useEffect(() => {\n    ref.current = value\n  })\n  return ref.current\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-interval-hook",children:"Custom Interval Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect, useRef } from 'react'\n\nfunction useInterval(callback: () => void, delay: number | null) {\n  const savedCallback = useRef(callback)\n\n  // Remember the latest callback if it changes.\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  // Set up the interval.\n  useEffect(() => {\n    // Don't schedule if no delay is specified.\n    if (delay === null)\n      return\n\n    const id = setInterval(() => savedCallback.current(), delay)\n\n    return () => clearInterval(id)\n  }, [delay])\n}\n\nexport default useInterval\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-debounce-hook",children:"Custom Debounce Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Hook\nfunction useDebounce(value, delay) {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState(value)\n\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value)\n      }, delay)\n\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      // This is how we prevent debounced value\n      // from updating if value is changed ...\n      // .. within the delay period. Timeout gets cleared and restarted.\n      return () => {\n        clearTimeout(handler)\n      }\n    },\n    [value, delay] // Only re-call effect if value or delay changes\n  )\n\n  return debouncedValue\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function App() {\n  // Usage\n  const [searchTerm, setSearchTerm] = useState('')\n  const debouncedSearchTerm = useDebounce(searchTerm, 500)\n\n  useEffect(() => {}, [debouncedSearchTerm])\n\n  return <div>App</div>\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-eventlistener-hook",children:"Custom EventListener Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useCallback, useEffect } from 'react'\n\nexport default function useKeydown() {\n  const handleKeydown = useCallback(() => {\n    alert('key is pressed.')\n  }, [])\n\n  useMount(() => {\n    document.addEventListener('keydown', handleKeydown)\n    return () => {\n      document.removeEventListener('keydown', handleKeydown)\n    }\n  })\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect } from 'react'\n\nexport default function useEventListener({ event, handler }) {\n  useMount(() => {\n    document.addEventListener(event, handler)\n    return () => {\n      document.removeEventListener(event, handler)\n    }\n  })\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-media-query-hook",children:"Custom Media Query Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default function useMedia<T>(\n  queries: string[],\n  values: T[],\n  defaultValue: T\n) {\n  // Array containing a media query list for each query\n  const mediaQueryLists = queries.map(q => window.matchMedia(q))\n\n  const getValue = () => {\n    // Get index of first media query that matches\n    const index = mediaQueryLists.findIndex(mql => mql.matches)\n    return values?.[index] || defaultValue\n  }\n\n  // State and setter for matched value\n  const [value, setValue] = useState<T>(getValue)\n\n  useMount(() => {\n    const handler = () => setValue(getValue)\n    mediaQueryLists.forEach(mql => mql.addListener(handler))\n    return () => mediaQueryLists.forEach(mql => mql.removeListener(handler))\n  })\n\n  return value\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-observer-hook",children:"Custom Observer Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type { RefObject } from 'react'\nimport { useEffect, useState } from 'react'\n\ninterface Args extends IntersectionObserverInit {\n  freezeOnceVisible?: boolean\n}\n\nfunction useIntersectionObserver(\n  elementRef: RefObject<Element>,\n  {\n    threshold = 0,\n    root = null,\n    rootMargin = '0%',\n    freezeOnceVisible = false,\n  }: Args\n): IntersectionObserverEntry | undefined {\n  const [entry, setEntry] = useState<IntersectionObserverEntry>()\n\n  const frozen = entry?.isIntersecting && freezeOnceVisible\n\n  // Update first entry\n  const updateEntry = ([entry]: IntersectionObserverEntry[]): void => {\n    setEntry(entry)\n  }\n\n  useEffect(() => {\n    const node = elementRef?.current // DOM Ref\n    const hasIOSupport = !!window.IntersectionObserver\n\n    if (!hasIOSupport || frozen || !node)\n      return\n\n    const observerParams = { threshold, root, rootMargin }\n    const observer = new IntersectionObserver(updateEntry, observerParams)\n\n    observer.observe(node)\n\n    return () => observer.disconnect()\n  }, [elementRef, threshold, root, rootMargin, frozen])\n\n  return entry\n}\n\nexport default useIntersectionObserver\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function useComponentSize() {\n  const [size, setSize] = React.useState({\n    height: 0,\n    width: 0,\n  })\n  const ref = React.useRef<any>()\n\n  const onResize = React.useCallback(() => {\n    if (!ref.current)\n      return\n\n    const newHeight = ref.current.offsetHeight\n    const newWidth = ref.current.offsetWidth\n\n    if (newHeight !== size.height || newWidth !== size.width) {\n      setSize({\n        height: newHeight,\n        width: newWidth,\n      })\n    }\n  }, [size.height, size.width])\n\n  React.useLayoutEffect(() => {\n    if (!ref || !ref.current)\n      return\n\n    const resizeObserver = new ResizeObserver(onResize)\n    resizeObserver.observe(ref.current)\n\n    return () => resizeObserver.disconnect()\n  }, [ref, onResize])\n\n  return {\n    ref,\n    ...size,\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-locked-body-hook",children:"Custom Locked Body Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect, useLayoutEffect, useState } from 'react'\n\ntype ReturnType = [boolean, (locked: boolean) => void]\n\nfunction useLockedBody(initialLocked = false): ReturnType {\n  const [locked, setLocked] = useState(initialLocked)\n\n  // Do the side effect before render\n  useLayoutEffect(() => {\n    // Key point 1\n    if (!locked)\n      return\n\n    // Save initial body style\n    const originalOverflow = document.body.style.overflow\n    const originalPaddingRight = document.body.style.paddingRight\n\n    // Lock body scroll\n    document.body.style.overflow = 'hidden'\n\n    // Get the scrollBar width\n    const root = document.getElementById('___gatsby') // or root\n    const scrollBarWidth = root ? root.offsetWidth - root.scrollWidth : 0\n\n    // Avoid width reflow\n    if (scrollBarWidth)\n      document.body.style.paddingRight = `${scrollBarWidth}px`\n\n    // Key point 2\n    return () => {\n      document.body.style.overflow = originalOverflow\n\n      if (scrollBarWidth)\n        document.body.style.paddingRight = originalPaddingRight\n    }\n  }, [locked])\n\n  // Update state if initialValue changes\n  useEffect(() => {\n    if (locked !== initialLocked)\n      setLocked(initialLocked)\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialLocked])\n\n  return [locked, setLocked]\n}\n\nexport default useLockedBody\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-mouse-hook",children:"Custom Mouse Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useRef, useState } from 'react'\n\nexport default function useLongPress(time = 500) {\n  const [action, setAction] = useState()\n\n  const timerRef = useRef()\n  const isLongPress = useRef()\n\n  function startPressTimer() {\n    isLongPress.current = false\n    timerRef.current = setTimeout(() => {\n      isLongPress.current = true\n      setAction('LongPress')\n    }, time)\n  }\n\n  function handleClick() {\n    if (isLongPress.current)\n      return\n\n    setAction('Click')\n  }\n\n  function handleMouseDown() {\n    startPressTimer()\n  }\n\n  function handleMouseUp() {\n    clearTimeout(timerRef.current)\n  }\n\n  function handleTouchStart() {\n    startPressTimer()\n  }\n\n  function handleTouchEnd() {\n    if (action === 'LongPress')\n      return\n\n    clearTimeout(timerRef.current)\n  }\n\n  return {\n    action,\n    handlers: {\n      onClick: handleClick,\n      onMouseDown: handleMouseDown,\n      onMouseUp: handleMouseUp,\n      onTouchStart: handleTouchStart,\n      onTouchEnd: handleTouchEnd,\n    },\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-form-hook",children:"Custom Form Hook"}),"\n",(0,r.jsx)(n.h4,{id:"usestate-only-form-hook",children:"UseState Only Form Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useState"})," for form entire state and form control data."]}),"\n",(0,r.jsxs)(n.li,{children:["Custom logic via hooks ",(0,r.jsx)(n.code,{children:"params"})," function."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useState } from 'react'\n\nfunction useForm(callback) {\n  const [values, setValues] = useState({})\n\n  const handleSubmit = (event) => {\n    if (event)\n      event.preventDefault()\n    callback()\n  }\n\n  const handleChange = (event) => {\n    event.persist()\n    setValues(values => ({\n      ...values,\n      [event.target.name]: event.target.value,\n    }))\n  }\n\n  return {\n    handleChange,\n    handleSubmit,\n    values,\n  }\n}\n\nexport default useForm\n"})}),"\n",(0,r.jsx)(n.h4,{id:"usestate-and-useref-form-hook",children:"UseState and UseRef Form Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useState"})," for form entire state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useRef"})," for form control data."]}),"\n",(0,r.jsxs)(n.li,{children:["Custom logic via hooks ",(0,r.jsx)(n.code,{children:"params"})," function."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export function useField(\n  name,\n  form,\n  { defaultValue, validations = [], fieldsToValidateOnChange = [name] } = {}\n) {\n  const [value, setValue] = useState(defaultValue)\n  const [errors, setErrors] = useState([])\n  const [pristine, setPristine] = useState(true)\n  const [validating, setValidating] = useState(false)\n  const validateCounter = useRef(0)\n\n  const validate = async () => {\n    const validateIteration = ++validateCounter.current\n    setValidating(true)\n    const formData = form.getFormData()\n    let errorMessages = await Promise.all(\n      validations.map(validation => validation(formData, name))\n    )\n    errorMessages = errorMessages.filter(Boolean)\n    if (validateIteration === validateCounter.current) {\n      // this is the most recent invocation\n      setErrors(errorMessages)\n      setValidating(false)\n    }\n    return errorMessages.length === 0\n  }\n\n  useEffect(() => {\n    if (pristine)\n      return // Avoid validate on mount\n    form.validateFields(fieldsToValidateOnChange)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value])\n\n  const field = {\n    name,\n    value,\n    errors,\n    setErrors,\n    pristine,\n    onChange: (e) => {\n      if (pristine)\n        setPristine(false)\n\n      setValue(e.target.value)\n    },\n    validate,\n    validating,\n  }\n  form.addField(field)\n  return field\n}\n\nexport function useForm({ onSubmit }) {\n  const [submitted, setSubmitted] = useState(false)\n  const [submitting, setSubmitting] = useState(false)\n  const fields = useRef([])\n\n  const validateFields = async (fieldNames) => {\n    let fieldsToValidate\n    if (Array.is(fieldNames)) {\n      fieldsToValidate = fields.current.filter(field =>\n        fieldNames.includes(field.name)\n      )\n    } else {\n      // If fieldNames not provided, validate all fields.\n      fieldsToValidate = fields.current\n    }\n    const fieldsValid = await Promise.all(\n      fieldsToValidate.map(field => field.validate())\n    )\n    return fieldsValid.every(Boolean)\n  }\n\n  const getFormData = () => {\n    return fields.current.reduce((formData, f) => {\n      formData[f.name] = f.value\n      return formData\n    }, {})\n  }\n\n  return {\n    onSubmit: async (e) => {\n      e.preventDefault()\n      setSubmitting(true)\n      setSubmitted(true) // User has attempted to submit form at least once\n      const formValid = await validateFields()\n      const returnVal = await onSubmit(getFormData(), formValid)\n      setSubmitting(false)\n      return returnVal\n    },\n    isValid: () => fields.current.every(f => f.errors.length === 0),\n    addField: field => fields.current.push(field),\n    getFormData,\n    validateFields,\n    submitted,\n    submitting,\n  }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'interface Props {\n  label: string\n  name: string\n  value: string\n  onChange: Function\n  errors: string[]\n  setErrors: Function[]\n  pristine: boolean\n  validating: boolean\n  validate: Function\n  formSubmitted: boolean\n}\n\nexport default function Field({\n  label,\n  name,\n  value,\n  onChange,\n  errors,\n  setErrors,\n  pristine,\n  validating,\n  validate,\n  formSubmitted,\n  ...other\n}: Props) {\n  const showErrors = (!pristine || formSubmitted) && !!errors.length\n\n  return (\n    <FormControl className="field" error={showErrors}>\n      <InputLabel htmlFor={name}>{label}</InputLabel>\n      <Input\n        id={name}\n        value={value}\n        onChange={onChange}\n        onBlur={() => !pristine && validate()}\n        endAdornment={(\n          <InputAdornment position="end">\n            {validating && <LoadingIcon className="rotate" />}\n          </InputAdornment>\n        )}\n        {...other}\n      />\n      <FormHelperText component="div">\n        {showErrors\n        && errors.map(errorMsg => <div key={errorMsg}>{errorMsg}</div>)}\n      </FormHelperText>\n    </FormControl>\n  )\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function App(props) {\n  const form = useForm({\n    onSubmit: async (formData, valid) => {\n      if (!valid)\n        return\n      await timeout(2000) // Simulate network time\n      if (formData.username.length < 10) {\n        // Simulate 400 response from server.\n        usernameField.setErrors(['Make a longer username'])\n      } else {\n        // Simulate 201 response from server.\n        window.alert(\n          `form valid: ${valid}, form data: ${JSON.stringify(formData)}`\n        )\n      }\n    },\n  })\n\n  const usernameField = useField('username', form, {\n    defaultValue: '',\n    validations: [\n      async (formData) => {\n        await timeout(2000)\n        return formData.username.length < 6 && 'Username already exists'\n      },\n    ],\n    fieldsToValidateOnChange: [],\n  })\n  const passwordField = useField('password', form, {\n    defaultValue: '',\n    validations: [\n      formData =>\n        formData.password.length < 6\n        && 'Password must be at least 6 characters',\n    ],\n    fieldsToValidateOnChange: ['password', 'confirmPassword'],\n  })\n  const confirmPasswordField = useField('confirmPassword', form, {\n    defaultValue: '',\n    validations: [\n      formData =>\n        formData.password !== formData.confirmPassword\n        && 'Passwords do not match',\n    ],\n    fieldsToValidateOnChange: ['password', 'confirmPassword'],\n  })\n\n  const requiredFields = [usernameField, passwordField, confirmPasswordField]\n\n  return (\n    <div id=\"form-container\">\n      <form onSubmit={form.onSubmit}>\n        <Field\n          {...usernameField}\n          formSubmitted={form.submitted}\n          label=\"Username\"\n        />\n        <Field\n          {...passwordField}\n          formSubmitted={form.submitted}\n          label=\"Password\"\n          type=\"password\"\n        />\n        <Field\n          {...confirmPasswordField}\n          formSubmitted={form.submitted}\n          label=\"Confirm Password\"\n          type=\"password\"\n        />\n        <Button\n          type=\"submit\"\n          disabled={\n            !form.isValid()\n            || form.submitting\n            || requiredFields.some(f => f.pristine)\n          }\n        >\n          {form.submitting ? 'Submitting' : 'Submit'}\n        </Button>\n      </form>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"usestate-and-useref-with-dom-refs-form-hook",children:"UseState and UseRef with DOM Refs Form Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useState"})," for form entire state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useRef"})," for form control data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Function Refs"})," bind to native ",(0,r.jsx)(n.code,{children:"<input />"})," elements."]}),"\n",(0,r.jsxs)(n.li,{children:["Custom logic via hooks ",(0,r.jsx)(n.code,{children:"return"})," function."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// https://github.com/react-hook-form/react-hook-form/blob/v7.29.0/src/logic/createFormControl.ts\nfunction createFormControl() {\n  return {\n    register: (name, options = {}) => {\n      // Register input filed.\n      let field = get(_fields, name)\n      const disabledIsDefined = isBoolean(options.disabled)\n\n      set(_fields, name, {\n        _f: {\n          ...(field && field._f ? field._f : { ref: { name } }),\n          name,\n          mount: true,\n          ...options,\n        },\n      })\n      _names.mount.add(name)\n\n      field\n        ? disabledIsDefined\n        && set(\n          _formValues,\n          name,\n          options.disabled\n            ? undefined\n            : get(_formValues, name, getFieldValue(field._f))\n        )\n        : updateValidAndValue(name, true, options.value)\n\n      return {\n        // Bind to Form Input Element.\n        ref: (ref: HTMLInputElement | null): void => {\n          if (ref) {\n            register(name, options)\n            field = get(_fields, name)\n\n            const fieldRef = isUndefined(ref.value)\n              ? ref.querySelectorAll\n                ? (ref.querySelectorAll('input,select,textarea')[0] as Ref)\n                || ref\n                : ref\n              : ref\n            const radioOrCheckbox = isRadioOrCheckbox(fieldRef)\n            const refs = field._f.refs || []\n\n            if (\n              radioOrCheckbox\n                ? refs.find((option: Ref) => option === fieldRef)\n                : fieldRef === field._f.ref\n            ) {\n              return\n            }\n\n            set(_fields, name, {\n              _f: {\n                ...field._f,\n                ...(radioOrCheckbox\n                  ? {\n                      refs: [...refs.filter(live), fieldRef],\n                      ref: { type: fieldRef.type, name },\n                    }\n                  : { ref: fieldRef }),\n              },\n            })\n\n            updateValidAndValue(name, false, undefined, fieldRef)\n          } else {\n            field = get(_fields, name, {})\n\n            if (field._f)\n              field._f.mount = false\n            ;(_options.shouldUnregister || options.shouldUnregister)\n            && !(isNameInFieldArray(_names.array, name) && _stateFlags.action)\n            && _names.unMount.add(name)\n          }\n        },\n        value,\n        min,\n        max,\n        required,\n        disabled,\n        ...fieldPropValues,\n      }\n    },\n    // Higher order function: onSubmit (Use Code) => onSubmit (Bind to Form Element).\n    handleSubmit: (onSubmit) => {\n      return (event: SubmitEvent) => {\n        onSubmit(this._getFormData())\n      }\n    },\n  }\n}\n\nfunction useForm() {\n  // Detailed logic handlers: DOM refs, field getter/setter, submit handler.\n  const formControl = useRef<FormControl>(createFormControl())\n  // Entire form state: valid, errors etc.\n  const formState = useState<FormState>()\n\n  return {\n    ...formControl.current,\n  }\n}\n\nexport default function App() {\n  const { register, handleSubmit } = useForm()\n  const onSubmit = data => console.log(data)\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <input {...register('name')} type=\"text\" />\n      <input {...register('password')} type=\"password\" />\n    </form>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-url-params-hook",children:"Custom URL Params Hook"}),"\n",(0,r.jsx)(n.p,{children:"Storing state in the URL:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default function useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const history = useHistory()\n  const search = new URLSearchParams(history.location.search)\n\n  const existingValue = search.get(paramsName)\n  const [state, setState] = useState<T>(\n    existingValue ? deserialize(existingValue) : initialState\n  )\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state)\n      setState(deserialize(existingValue))\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [existingValue])\n\n  const onChange = (s: T) => {\n    setState(s)\n    const searchParams = new URLSearchParams(history.location.search)\n    searchParams.set(paramsName, serialize(s))\n    const pathname = history.location.pathname\n    history.push({ pathname, search: searchParams.toString() })\n  }\n\n  return [state, onChange]\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-router-hook",children:"Custom Router Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useContext, useEffect } from 'react'\nimport { __RouterContext } from 'react-router'\nimport useForceUpdate from 'use-force-update'\n\nfunction useReactRouter() {\n  const forceUpdate = useForceUpdate()\n  const routerContext = useContext(__RouterContext)\n\n  useEffect(\n    () => routerContext.history.listen(forceUpdate),\n    [forceUpdate, routerContext]\n  )\n\n  return routerContext\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-history-hook",children:"Custom History Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useCallback, useReducer } from 'react'\n\n// Initial state that we pass into useReducer\nconst initialState = {\n  // Array of previous state values updated each time we push a new state\n  past: [],\n  // Current state value\n  present: null,\n  // Will contain \"future\" state values if we undo (so we can redo)\n  future: [],\n}\n\n// Our reducer function to handle state changes based on action\nfunction reducer(state, action) {\n  const { past, present, future } = state\n\n  switch (action.type) {\n    case 'UNDO': {\n      const previous = past[past.length - 1]\n      const newPast = past.slice(0, past.length - 1)\n\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future],\n      }\n    }\n    case 'REDO': {\n      const next = future[0]\n      const newFuture = future.slice(1)\n\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture,\n      }\n    }\n    case 'SET': {\n      const { newPresent } = action\n\n      if (newPresent === present)\n        return state\n\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: [],\n      }\n    }\n    case 'CLEAR': {\n      const { initialPresent } = action\n\n      return {\n        ...initialState,\n        present: initialPresent,\n      }\n    }\n    default:\n      throw new Error('Unsupported action type!')\n  }\n}\n\n// Hook\nfunction useHistory(initialPresent) {\n  const [state, dispatch] = useReducer(reducer, {\n    ...initialState,\n    present: initialPresent,\n  })\n\n  const canUndo = state.past.length !== 0\n  const canRedo = state.future.length !== 0\n\n  // Setup our callback functions\n  // We memoize with useCallback to prevent unnecessary re-renders\n\n  const undo = useCallback(() => {\n    if (canUndo)\n      dispatch({ type: 'UNDO' })\n  }, [dispatch, canUndo])\n\n  const redo = useCallback(() => {\n    if (canRedo)\n      dispatch({ type: 'REDO' })\n  }, [dispatch, canRedo])\n\n  const set = useCallback(\n    newPresent => dispatch({ type: 'SET', newPresent }),\n    [dispatch]\n  )\n\n  const clear = useCallback(\n    () => dispatch({ type: 'CLEAR', initialPresent }),\n    [dispatch, initialPresent]\n  )\n\n  // If needed we could also return past and future state\n  return { state: state.present, set, undo, redo, clear, canUndo, canRedo }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-script-loading-hook",children:"Custom Script Loading Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect, useState } from 'react'\n\nexport type Status = 'idle' | 'loading' | 'ready' | 'error'\nexport type ScriptElt = HTMLScriptElement | null\n\nfunction useScript(src: string): Status {\n  const [status, setStatus] = useState<Status>(src ? 'loading' : 'idle')\n\n  useEffect(\n    () => {\n      if (!src) {\n        setStatus('idle')\n        return\n      }\n\n      // Fetch existing script element by src\n      // It may have been added by another instance of this hook\n      // **Cache mechanism**\n      let script: ScriptElt = document.querySelector(`script[src=\"${src}\"]`)\n\n      if (!script) {\n        // Create script\n        script = document.createElement('script')\n        script.src = src\n        script.async = true\n        script.setAttribute('data-status', 'loading')\n        // Add script to document body\n        document.body.appendChild(script)\n\n        // Store status in attribute on script\n        // This can be read by other instances of this hook\n        const setAttributeFromEvent = (event: Event) => {\n          script?.setAttribute(\n            'data-status',\n            event.type === 'load' ? 'ready' : 'error'\n          )\n        }\n\n        script.addEventListener('load', setAttributeFromEvent)\n        script.addEventListener('error', setAttributeFromEvent)\n      } else {\n        // Grab existing script status from attribute and set to state.\n        setStatus(script.getAttribute('data-status') as Status)\n      }\n\n      // Script event handler to update status in state\n      // Note: Even if the script already exists we still need to add\n      // event handlers to update the state for *this* hook instance.\n      const setStateFromEvent = (event: Event) => {\n        setStatus(event.type === 'load' ? 'ready' : 'error')\n      }\n\n      // Add event listeners\n      script.addEventListener('load', setStateFromEvent)\n      script.addEventListener('error', setStateFromEvent)\n\n      // Remove event listeners on cleanup\n      return () => {\n        if (script) {\n          script.removeEventListener('load', setStateFromEvent)\n          script.removeEventListener('error', setStateFromEvent)\n        }\n      }\n    },\n    [src] // Only re-run effect if script src changes\n  )\n\n  return status\n}\n\nexport default useScript\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const cachedScripts = []\n\nfunction useScript(src) {\n  // Keeping track of script loaded and error state\n  const [state, setState] = useState({\n    loaded: false,\n    error: false,\n  })\n\n  useEffect(\n    () => {\n      // If cachedScripts array already includes src\n      // that means another instance ...\n      // ... of this hook already loaded this script, so no need to load again.\n      if (cachedScripts.includes(src)) {\n        setState({\n          loaded: true,\n          error: false,\n        })\n      } else {\n        cachedScripts.push(src)\n\n        // Create script\n        const script = document.createElement('script')\n        script.src = src\n        script.async = true\n\n        // Script event listener callbacks for load and error\n        const onScriptLoad = () => {\n          setState({\n            loaded: true,\n            error: false,\n          })\n        }\n\n        const onScriptError = () => {\n          // Remove from cachedScripts we can try loading again\n          const index = cachedScripts.indexOf(src)\n          if (index >= 0)\n            cachedScripts.splice(index, 1)\n          script.remove()\n\n          setState({\n            loaded: true,\n            error: true,\n          })\n        }\n\n        script.addEventListener('load', onScriptLoad)\n        script.addEventListener('error', onScriptError)\n\n        // Add script to document body\n        document.body.appendChild(script)\n\n        // Remove event listeners on cleanup\n        return () => {\n          script.removeEventListener('load', onScriptLoad)\n          script.removeEventListener('error', onScriptError)\n        }\n      }\n    },\n    [src] // Only re-run effect if script src changes\n  )\n\n  return [state.loaded, state.error]\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-cookie-hook",children:"Custom Cookie Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// https://github.com/tylerwolff/useCookie.\nimport { useState } from 'react'\n\nconst isBrowser = typeof window !== 'undefined'\n\nfunction stringifyOptions(options) {\n  return Object.keys(options).reduce((acc, key) => {\n    if (key === 'days') {\n      // Skip `days`.\n      return acc\n    } else {\n      if (options[key] === false)\n        return acc\n      else if (options[key] === true)\n        return `${acc}; ${key}`\n      else return `${acc}; ${key}=${options[key]}`\n    }\n  }, '')\n}\n\nfunction getCookie(name, initialValue = '') {\n  return (\n    (isBrowser\n      && document.cookie.split('; ').reduce((r, v) => {\n        const parts = v.split('=')\n        return parts[0] === name ? decodeURIComponent(parts[1]) : r\n      }, ''))\n      || initialValue\n  )\n}\n\nfunction setCookie(name, value, options) {\n  if (!isBrowser)\n    return\n\n  const optionsWithDefaults = {\n    days: 7,\n    path: '/',\n    ...options,\n  }\n\n  const expires = new Date(\n    Date.now() + optionsWithDefaults.days * 864e5\n  ).toUTCString()\n\n  document.cookie = `${name}=${encodeURIComponent(\n    value\n  )}; expires=${expires}${stringifyOptions(optionsWithDefaults)}`\n}\n\nfunction useCookie(key, initialValue) {\n  const [item, setItem] = useState(() => {\n    return getCookie(key, initialValue)\n  })\n\n  const updateItem = (value, options) => {\n    setItem(value)\n    setCookie(key, value, options)\n  }\n\n  return [item, updateItem]\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-localstorage-hook",children:"Custom LocalStorage Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// https://www.robinwieruch.de/react-uselocalstorage-hook.\nfunction useLocalStorage(storageKey, fallbackState) {\n  const [value, setValue] = React.useState(\n    JSON.parse(localStorage.getItem(storageKey)) || fallbackState\n  )\n\n  // Update logic.\n  React.useEffect(() => {\n    localStorage.setItem(storageKey, JSON.stringify(value))\n  }, [value, storageKey])\n\n  return [value, setValue]\n}\n\nexport default function App() {\n  const [isOpen, setOpen] = useLocalStorage('is-open', false)\n\n  const handleToggle = () => {\n    setOpen(!isOpen)\n  }\n\n  return (\n    <div>\n      <button type=\"button\" onClick={handleToggle}>Toggle</button>\n      {isOpen && <div>Content</div>}\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-async-data-hook",children:"Custom Async Data Hook"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useState"})," to store url and data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," to trigger async ",(0,r.jsx)(n.code,{children:"fetch"})," actions."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect, useState } from 'react'\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null)\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline)\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange)\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange)\n    }\n  })\n\n  return isOnline\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id)\n\n  if (isOnline === null)\n    return 'Loading...'\n\n  return isOnline ? 'Online' : 'Offline'\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"interface Props {\n  friend: {\n    id: number\n    name: string\n  }\n}\nexport default function FriendListItem({ friend }: Props) {\n  const isOnline = useFriendStatus(friend.id)\n\n  return (\n    <li style={{ color: isOnline ? 'green' : 'black' }}>{friend.name}</li>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios'\nimport { Fragment, useEffect, useState } from 'react'\n\nfunction useDataApi(initialUrl, initialData) {\n  const [data, setData] = useState(initialData)\n  const [url, setUrl] = useState(initialUrl)\n  const [isLoading, setIsLoading] = useState(false)\n  const [isError, setIsError] = useState(false)\n\n  const fetchData = useCallback(async () => {\n    setIsError(false)\n    setIsLoading(true)\n\n    try {\n      const result = await axios(url)\n\n      setData(result.data)\n    } catch (error) {\n      setIsError(true)\n    }\n\n    setIsLoading(false)\n  }, [url])\n\n  useEffect(() => {\n    fetchData()\n  }, [fetchData])\n\n  const doGet = (event, url) => {\n    setUrl(url)\n    event.preventDefault()\n  }\n\n  return { data, isLoading, isError, doGet }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const [query, setQuery] = useState('redux')\n  const { data, isLoading, isError, doGet } = useDataApi(\n    'http://hn.algolia.com/api/v1/search?query=redux',\n    { hits: [] }\n  )\n\n  return (\n    <>\n      <form\n        onSubmit={event =>\n          doGet(event, `http://hn.algolia.com/api/v1/search?query=${query}`)}\n      >\n        <input\n          type=\"text\"\n          value={query}\n          onChange={event => setQuery(event.target.value)}\n        />\n        <button type=\"submit\">Search</button>\n      </form>\n\n      {isError && <div>Something went wrong ...</div>}\n\n      {isLoading\n        ? (\n            <div>Loading ...</div>\n          )\n        : (\n            <ul>\n              {data.hits.map(item => (\n                <li key={item.objectID}>\n                  <a href={item.url}>{item.title}</a>\n                </li>\n              ))}\n            </ul>\n          )}\n    </>\n  )\n}\n\nexport default App\n"})}),"\n",(0,r.jsx)(n.p,{children:"TypeScript fetch hook with caches:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type { AxiosRequestConfig } from 'axios'\n\nimport axios from 'axios'\nimport { useEffect, useReducer, useRef } from 'react'\n\n// State & hook output\ninterface State<T> {\n  status: 'init' | 'fetching' | 'error' | 'fetched'\n  data?: T\n  error?: string\n}\n\ntype Cache<T> = Record<string, T>\n\n// discriminated union type\ntype Action<T> =\n  | { type: 'request' }\n  | { type: 'success', payload: T }\n  | { type: 'failure', payload: string }\n\nfunction useFetch<T = unknown>(\n  url?: string,\n  options?: AxiosRequestConfig\n): State<T> {\n  const cache = useRef<Cache<T>>({})\n  const cancelRequest = useRef<boolean>(false)\n\n  const initialState: State<T> = {\n    status: 'init',\n    error: undefined,\n    data: undefined,\n  }\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case 'request':\n        return { ...initialState, status: 'fetching' }\n      case 'success':\n        return { ...initialState, status: 'fetched', data: action.payload }\n      case 'failure':\n        return { ...initialState, status: 'error', error: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState)\n\n  useEffect(() => {\n    if (!url)\n      return\n\n    const fetchData = async () => {\n      dispatch({ type: 'request' })\n\n      if (cache.current[url]) {\n        dispatch({ type: 'success', payload: cache.current[url] })\n      } else {\n        try {\n          const response = await axios(url, options)\n          cache.current[url] = response.data\n\n          if (cancelRequest.current)\n            return\n\n          dispatch({ type: 'success', payload: response.data })\n        } catch (error) {\n          if (cancelRequest.current)\n            return\n\n          dispatch({ type: 'failure', payload: error.message })\n        }\n      }\n    }\n\n    fetchData()\n\n    return () => {\n      cancelRequest.current = true\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url])\n\n  return state\n}\n\nexport default useFetch\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-data-query-hook",children:"Custom Data Query Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type { UseQueryOptions } from 'react-query'\nimport firebase from 'firebase/app'\nimport { useEffect } from 'react'\nimport { useQuery, useQueryClient } from 'react-query'\nimport 'firebase/auth'\nimport 'firebase/database'\n\n// This value is the default 403 code from firebase\nconst PERMISSION_DENIED_STATUS_CODE = 'PERMISSION_DENIED'\n\nexport interface RealTimeFetchParams {\n  path: string\n}\n\nexport interface RealTimeSubscribeParams<T> {\n  path: string\n  event?: firebase.database.EventType\n  callback: (value: T) => void\n}\n\nexport interface RealTimeUnsubscribeParams {\n  path: string\n  event?: firebase.database.EventType\n}\n\nexport class RealTimeApi {\n  private firebase: firebase.app.App\n\n  constructor() {\n    this.handleAuthenticationErrors = this.handleAuthenticationErrors.bind(this)\n\n    this.firebase = firebase.initializeApp({\n      apiKey: process.env.REACT_APP_FIREBASE_WEB_API_KEY,\n      databaseURL: process.env.REACT_APP_FIREBASE_DATABASE_URL,\n      projectId: process.env.REACT_APP_FIREBASE_DATABASE_URL,\n      messagingSenderId: process.env.REACT_APP_FIREBASE_SENDER_ID,\n      appId: process.env.REACT_APP_FIREBASE_APP_ID,\n    })\n  }\n\n  private handleAuthenticationErrors(error: firebase.FirebaseError) {\n    if (error.code === PERMISSION_DENIED_STATUS_CODE) {\n      // handle logout any way you want. For example, if you were using\n      // AWS Cognito, you'd call `Auth.logout()`\n    }\n  }\n\n  public connect(token: string) {\n    return this.firebase.auth().signInWithCustomToken(token)\n  }\n\n  public disconnect() {\n    return this.firebase.auth().signOut()\n  }\n\n  public fetch<T>({ path }: RealTimeFetchParams) {\n    return new Promise<T>((resolve) => {\n      this.firebase\n        .database()\n        .ref(path)\n        .once(\n          'value',\n          (snapshot) => {\n            resolve(snapshot.val())\n          },\n          this.handleAuthenticationErrors\n        )\n    })\n  }\n\n  public subscribe<T>({\n    path,\n    callback,\n    event = 'value',\n  }: RealTimeSubscribeParams<T>) {\n    const ref = this.firebase.database().ref(path)\n    const cb = (snapshot: firebase.database.DataSnapshot) => {\n      callback(snapshot.val() as T)\n    }\n\n    ref.on(event, cb, this.handleAuthenticationErrors)\n    return () => ref.off(event, cb)\n  }\n\n  public unsubscribe({ path, event = 'value' }: RealTimeUnsubscribeParams) {\n    this.firebase.database().ref(path).off(event)\n  }\n}\n\nconst realTimeApi = new RealTimeApi()\n\nfunction useRealTimeQuery<Data>(\n  firebasePathKey: string,\n  useQueryOptions: UseQueryOptions<Data> = {}\n) {\n  const queryClient = useQueryClient()\n\n  useEffect(() => {\n    const unsubscribe = realTimeApi.subscribe<Data>({\n      path: firebasePathKey,\n      callback: (val) => {\n        queryClient.setQueryData(firebasePathKey, val)\n      },\n    })\n\n    return () => unsubscribe()\n  }, [queryClient, firebasePathKey])\n\n  return useQuery<Data, Error>(\n    firebasePathKey,\n    () => new Promise<Data>(() => {}),\n    useQueryOptions\n  )\n}\n\nexport default useRealTimeQuery\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-store-hook",children:"Custom Store Hook"}),"\n",(0,r.jsx)(n.p,{children:"Simple implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useState } from 'react'\n\nexport const store = {\n  state: {},\n  setState(value) {\n    this.state = value\n    this.setters.forEach(setter => setter(this.state))\n  },\n  setters: [],\n}\n\n// Bind the setState function to the store object so\n// we don't lose context when calling it elsewhere\nstore.setState = store.setState.bind(store)\n\n// this is the custom hook we'll call on components.\nexport default function useStore() {\n  const [state, set] = useState(store.state)\n\n  if (!store.setters.includes(set))\n    store.setters.push(set)\n\n  return [state, store.setState]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Complex ",(0,r.jsx)(n.a,{href:"https://github.com/timc1/kbar",children:"implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type {\n  Action,\n  ActionId,\n  ActionTree,\n  KBarOptions,\n  KBarProviderProps,\n  KBarState,\n} from './types'\nimport { deepEqual } from 'fast-equals'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { VisualState } from './types'\n\ntype useStoreProps = KBarProviderProps\n\nexport default function useStore(props: useStoreProps) {\n  if (!props.actions) {\n    throw new Error(\n      'You must define a list of `actions` when calling KBarProvider'\n    )\n  }\n\n  const [state, setState] = useState<KBarState>({\n    searchQuery: '',\n    currentRootActionId: null,\n    visualState: VisualState.hidden,\n    actions: props.actions.reduce((acc, current) => {\n      acc[current.id] = current\n      return acc\n    }, {}),\n  })\n\n  const currentState = useRef(state)\n  currentState.current = state\n\n  const getState = useCallback(() => currentState.current, [])\n  const publisher = useMemo(() => new Publisher(getState), [getState])\n\n  useEffect(() => {\n    currentState.current = state\n    publisher.notify()\n  }, [publisher, state])\n\n  const optionsRef = useRef((props.options || {}) as KBarOptions)\n\n  const registerActions = useCallback((actions: Action[]) => {\n    const actionsByKey: ActionTree = actions.reduce((acc, current) => {\n      acc[current.id] = current\n      return acc\n    }, {})\n\n    setState(state => ({\n      ...state,\n      actions: {\n        ...actionsByKey,\n        ...state.actions,\n      },\n    }))\n\n    return function unregister() {\n      setState((state) => {\n        const actions = state.actions\n        const removeActionIds = Object.keys(actionsByKey)\n        removeActionIds.forEach(actionId => delete actions[actionId])\n        return {\n          ...state,\n          actions: {\n            ...state.actions,\n            ...actions,\n          },\n        }\n      })\n    }\n  }, [])\n\n  return useMemo(() => {\n    return {\n      getState,\n      query: {\n        setCurrentRootAction: (actionId: ActionId | null | undefined) => {\n          setState(state => ({\n            ...state,\n            currentRootActionId: actionId,\n          }))\n        },\n        setVisualState: (\n          cb: ((vs: VisualState) => VisualState) | VisualState\n        ) => {\n          setState(state => ({\n            ...state,\n            visualState: typeof cb === 'function' ? cb(state.visualState) : cb,\n          }))\n        },\n        setSearch: (searchQuery: string) =>\n          setState(state => ({\n            ...state,\n            searchQuery,\n          })),\n        registerActions,\n      },\n      options: optionsRef.current,\n      subscribe: (\n        collector: <C>(state: KBarState) => C,\n        cb: <C>(collected: C) => void\n      ) => publisher.subscribe(collector, cb),\n    }\n  }, [getState, publisher, registerActions])\n}\n\nclass Publisher {\n  getState\n  subscribers: Subscriber[] = []\n\n  constructor(getState: () => KBarState) {\n    this.getState = getState\n  }\n\n  subscribe<C>(\n    collector: (state: KBarState) => C,\n    onChange: (collected: C) => void\n  ) {\n    const subscriber = new Subscriber(\n      () => collector(this.getState()),\n      onChange\n    )\n    this.subscribers.push(subscriber)\n    return this.unsubscribe.bind(this, subscriber)\n  }\n\n  unsubscribe(subscriber: Subscriber) {\n    if (this.subscribers.length) {\n      const index = this.subscribers.indexOf(subscriber)\n      if (index > -1)\n        return this.subscribers.splice(index, 1)\n    }\n  }\n\n  notify() {\n    this.subscribers.forEach(subscriber => subscriber.collect())\n  }\n}\n\nclass Subscriber {\n  collected: any // Previous state cache.\n  collector\n  onChange\n\n  constructor(collector: () => any, onChange: (collected: any) => any) {\n    this.collector = collector\n    this.onChange = onChange\n  }\n\n  collect() {\n    try {\n      // Grab latest state.\n      const recollect = this.collector()\n      if (!deepEqual(recollect, this.collected)) {\n        this.collected = recollect\n        if (this.onChange)\n          this.onChange(this.collected)\n      }\n    } catch (error) {\n      console.warn(error)\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-recoil-hook",children:"Custom Recoil Hook"}),"\n",(0,r.jsxs)(n.p,{children:["Recoil ",(0,r.jsx)(n.a,{href:"https://github.com/bennetthardwick/recoil-clone",children:"minimal implementation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Atom"}),": collect children callbacks as ",(0,r.jsx)(n.code,{children:"listeners"}),", notify children when value changed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Selector"}),": collect parent ",(0,r.jsx)(n.code,{children:"Atoms"})," as ",(0,r.jsx)(n.code,{children:"deps"}),", update value when parent Atoms notified."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface Disconnector {\n  disconnect: () => void\n}\n\nclass Stateful<T> {\n  private listeners = new Set<(value: T) => void>()\n\n  constructor(private value: T) {}\n\n  protected _update(value: T) {\n    this.value = value\n    this.notify()\n  }\n\n  snapshot(): T {\n    return this.value\n  }\n\n  notify() {\n    for (const listener of this.listeners) listener(this.snapshot())\n  }\n\n  subscribe(callback: (value: T) => void): Disconnector {\n    this.listeners.add(callback)\n    return {\n      disconnect: () => {\n        this.listeners.delete(callback)\n      },\n    }\n  }\n}\n\nclass Atom<T> extends Stateful<T> {\n  update(value: T) {\n    super._update(value)\n  }\n}\n\ninterface GeneratorContext {\n  get: <V>(dependency: Stateful<V>) => V\n}\n\ntype SelectorGenerator<T> = (context: GeneratorContext) => T\n\nexport class Selector<T> extends Stateful<T> {\n  private registeredDeps = new Set<Stateful>()\n\n  constructor(private readonly generate: SelectorGenerator<T>) {\n    super(undefined as any)\n    const context = { get: dep => this.getDep(dep) }\n    this.value = generate(context)\n  }\n\n  private getDep<V>(dep: Stateful<V>): V {\n    if (!this.registeredDeps.has(dep)) {\n      // Update when parent Atom changed.\n      dep.subscribe(() => this.updateSelector())\n      this.registeredDeps.add(dep)\n    }\n\n    return dep.snapshot()\n  }\n\n  private updateSelector() {\n    const context = { get: dep => this.getDep(dep) }\n    this.update(this.generate(context))\n  }\n}\n\nexport function atom<V>(value: { key: string, default: V }): Atom<V> {\n  return new Atom(value.default)\n}\n\nexport function selector<V>(value: {\n  key: string\n  get: SelectorGenerator<V>\n}): Selector<V> {\n  return new Selector(value.get)\n}\n\n// This hook will re-render whenever supplied `Stateful` value changes.\n// It can be used with `Selector` or `Atom`.\nexport function useCoiledValue<T>(value: Stateful<T>): T {\n  const [, updateState] = useState({})\n\n  // Force update when value changed.\n  useEffect(() => {\n    const { disconnect } = value.subscribe(() => updateState({}))\n    return () => disconnect()\n  }, [value])\n\n  return value.snapshot()\n}\n\n// Similar to above method, but it also lets set state.\n// It only can be used with `Atom`.\nexport function useCoiledState<T>(atom: Atom<T>): [T, (value: T) => void] {\n  const value = useCoiledValue(atom)\n  return [value, useCallback(value => atom.update(value), [atom])]\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function generate(context) {\n  // Register NameAtom as a dependency and get its snapshot value:\n  // get(nameAtom) => selector.getDep(nameAtom)\n  // => nameAtom.subscribe(() => selector.updateSelector) + selector.deps.add(nameAtom)\n  const name = context.get(nameAtom)\n  // Do the same for AgeAtom\n  const age = context.get(ageAtom)\n\n  // Return new value using parent atoms.\n  // E.g. 'Bob is 20 years old'.\n  return `${name} is ${age} years old.`\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-atom-hook",children:"Custom Atom Hook"}),"\n",(0,r.jsx)(n.p,{children:"Simple global store based on:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Subscribe pattern."}),"\n",(0,r.jsx)(n.li,{children:"UseState hook."}),"\n",(0,r.jsxs)(n.li,{children:["Atomic state library: e.g ",(0,r.jsx)(n.a,{href:"https://blog.axlight.com/posts/jotai-tips",children:"Jotai"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type { Dispatch, MutableRefObject, SetStateAction } from 'react'\nimport { nanoid } from 'nanoid'\nimport { useEffect, useRef, useState } from 'react'\n\nconst store = new Map<string, any>()\n\nclass Atom<T> {\n  key = nanoid()\n  subscribers = new Map<\n    MutableRefObject<boolean>,\n    Dispatch<SetStateAction<T>>\n  >()\n\n  private _current: T\n\n  constructor(initialState: T) {\n    store.set(this.key, initialState)\n    this._current = initialState\n  }\n\n  subscribe(\n    ref: MutableRefObject<boolean>,\n    action: Dispatch<SetStateAction<T>>\n  ) {\n    this.subscribers.set(ref, action)\n  }\n\n  unsubscribe(ref: MutableRefObject<boolean>) {\n    this.subscribers.delete(ref)\n  }\n\n  setState(nextState: T) {\n    this._current = nextState\n    store.set(this.key, nextState)\n    this.subscribers.forEach(action => action(nextState))\n  }\n\n  get current() {\n    return this._current\n  }\n}\n\nexport const atom = <T>(initialState: T) => new Atom(initialState)\n\nexport function useAtomValue<T>(atom: Atom<T>) {\n  const ref = useRef(false)\n  const [state, setState] = useState(atom.current)\n\n  if (ref.current === false) {\n    ref.current = true\n    atom.subscribe(ref, setState)\n  }\n\n  useMount(() => () => atom.unsubscribe(ref))\n\n  return state\n}\n\nexport function setAtomValue<T>(atom: Atom<T>) {\n  return (nextState: T) => atom.setState(nextState)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-zustand-hook",children:"Custom Zustand Hook"}),"\n",(0,r.jsxs)(n.p,{children:["Zustand ",(0,r.jsx)(n.a,{href:"https://gist.github.com/arkatsy/7ff5b6cd95fe94b5e480972a0d116aeb",children:"internals"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"/**\n * For more on the useSyncExternalStore hook.\n * @see https://react.dev/reference/react/useSyncExternalStore\n */\nimport { useSyncExternalStore } from 'react'\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/vanilla.ts#L57-L94\nfunction createStore(createState) {\n  let state\n  let initialState\n  const listeners = new Set()\n\n  const setState = (partial) => {\n    const nextState = typeof partial === 'function' ? partial(state) : partial\n\n    if (!Object.is(nextState, state)) {\n      const previousState = state\n      state = Object.assign({}, state, nextState)\n      listeners.forEach(listener => listener(state, previousState))\n    }\n  }\n\n  const getState = () => state\n  const getInitialState = () => initialState\n\n  const subscribe = (listener) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }\n\n  const api = { setState, getState, getInitialState, subscribe }\n  initialState = state = createState(setState, getState, api)\n\n  return api\n}\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/react.ts#L21\nconst identity = state => state\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/react.ts#L29-L40\nfunction useStore(api, selector = identity) {\n  const slice = useSyncExternalStore(\n    api.subscribe,\n    () => selector(api.getState()),\n    () => selector(api.getInitialState())\n  )\n\n  return slice\n}\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/react.ts#L56-L64\nfunction create(createState) {\n  const api = createStore(createState)\n  const useBoundStore = selector => useStore(api, selector)\n  Object.assign(useBoundStore, api)\n\n  return useBoundStore\n}\n\n// Usage\nconst useCountStore = create(set => ({\n  count: 0,\n  increment: () => set(state => ({ count: state.count + 1 })),\n  decrement: () => set(state => ({ count: state.count - 1 })),\n}))\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'function App() {\n  return (\n    <div>\n      <Counter1 />\n      <Counter2 />\n    </div>\n  )\n}\n\nfunction Counter1() {\n  const { count, increment, decrement } = useCountStore()\n\n  return (\n    <div>\n      <h2>Counter1</h2>\n      <div>{count}</div>\n      <button type="button" onClick={decrement}>-</button>\n      <button type="button" onClick={increment}>+</button>\n    </div>\n  )\n}\n\nfunction Counter2() {\n  const { count, increment, decrement } = useCountStore()\n\n  return (\n    <div>\n      <h2>Counter2</h2>\n      <div>{count}</div>\n      <button type="button" onClick={decrement}>-</button>\n      <button type="button" onClick={increment}>+</button>\n    </div>\n  )\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"hooks-best-practice",children:"Hooks Best Practice"}),"\n",(0,r.jsx)(n.p,{children:"\u5982\u679c\u5c06\u4e00\u4e2a\u51fd\u6570\u4efb\u610f\u5730\u5c06\u5176\u653e\u5728 useEffect Deps List \u4e2d\n\u53ef\u80fd\u4f1a\u5bfc\u81f4\u91cd\u590d\u65e0\u610f\u4e49\u7684 useEffect \u6267\u884c\n(\u56e0\u4e3a\u6bcf\u6b21 render \u671f\u95f4\u7684\u6b64\u51fd\u6570\u90fd\u4f1a\u91cd\u65b0\u5b9a\u4e49).\n\u6709\u4e24\u4e2a\u89e3\u51b3\u529e\u6cd5:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u5bf9\u4e8e\u88ab\u591a\u6b21\u590d\u7528 Utils \u51fd\u6570 (\u4e14\u4e0d\u4f9d\u8d56\u7ec4\u4ef6\u7684\u4efb\u4f55\u503c),\n\u5e94\u8be5\u63d0\u5230\u7ec4\u4ef6\u5916\u9762\u7684\u516c\u5171\u533a\u57df\u53bb\u5b9a\u4e49."}),"\n",(0,r.jsx)(n.li,{children:"\u5bf9\u4e8e\u53ea\u88ab\u7279\u5b9a Effect Hook \u8c03\u7528\u7684 Utils \u51fd\u6570,\n\u53ef\u4ee5\u653e\u5230 useEffect \u5185\u90e8\u5b9a\u4e49."}),"\n",(0,r.jsx)(n.li,{children:"\u5bf9\u4e8e\u5176\u4ed6\u9700\u8981\u5728\u7ec4\u4ef6\u5185(\u6216\u81ea\u5b9a\u4e49 Hooks \u5185)\u5b9a\u4e49\u7684\u51fd\u6570,\n\u53ef\u4f7f\u7528 useCallback \u5305\u88f9\u51fd\u6570, \u5e76\u8bbe\u7f6e\u6b63\u786e\u7684 Deps List,\n\u5c3d\u53ef\u80fd\u5730\u51cf\u5c11 render \u65f6\u91cd\u65b0\u5b9a\u4e49\u6b64\u51fd\u6570."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// \u2705 Not affected by the data flow\nfunction getFetchUrl(query) {\n  return `https://hn.algolia.com/api/v1/search?query=${query}`\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react')\n    // ... Fetch data and do something ...\n  }, []) // \u2705 Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux')\n    // ... Fetch data and do something ...\n  }, []) // \u2705 Deps are OK\n\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Don't forget to cleanup side effects (return function in useEffect)"}),"\n",(0,r.jsxs)(n.li,{children:["Set correct deps list for useEffect:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"avoid object deps (should use object property)."}),"\n",(0,r.jsx)(n.li,{children:"enough deps list to avoid infinite loop rendering pitfall."}),"\n",(0,r.jsx)(n.li,{children:"enough deps list to avoid stale closure."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"setState(state => state + 1) is better (avoid outdated state)."}),"\n",(0,r.jsxs)(n.li,{children:["Change ",(0,r.jsx)(n.code,{children:"useState"})," to ",(0,r.jsx)(n.code,{children:"useRef"})," when values not for rendering."]}),"\n",(0,r.jsxs)(n.li,{children:["Don't put any ",(0,r.jsx)(n.code,{children:"if"})," statement before hooks function."]}),"\n",(0,r.jsx)(n.li,{children:"Only call Hooks at the top level (don't inside loops, conditions or nested functions)."}),"\n",(0,r.jsx)(n.li,{children:"Only call Hooks from React function components."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},842:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(8101);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);